{
  "resolvedId": "/Users/sebastianwessel/projekte/voyage/node_modules/@formkit/vue/dist/index.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { defineComponent, getCurrentInstance, markRaw, watch, watchEffect, reactive, onMounted, onUnmounted, ref, provide, h, inject, computed, toRef, onBeforeUnmount, KeepAlive, Suspense, nextTick, triggerRef, isRef, isReactive, createTextVNode, resolveComponent } from 'vue';\nimport { createConfig, createNode, error, createMessage, getNode, clearErrors, setErrors, submitForm, reset, createClasses, generateClassList, warn, watchRegistry, isNode, sugar, isDOM, isComponent, isConditional, compile } from '@formkit/core';\nexport { clearErrors, errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';\nimport { cloneAny, extend, undefine, camel, kebab, nodeProps, only, except, oncePerTick, slugify, shallowClone, eq, token, isObject, empty, has, isPojo } from '@formkit/utils';\nimport { createObserver } from '@formkit/observer';\nimport * as defaultRules from '@formkit/rules';\nimport { createValidationPlugin } from '@formkit/validation';\nimport { createI18nPlugin, en } from '@formkit/i18n';\nexport { changeLocale } from '@formkit/i18n';\nimport { createSection, useSchema, localize, createLibraryPlugin, inputs, runtimeProps } from '@formkit/inputs';\nimport { createIconHandler, createThemePlugin } from '@formkit/themes';\nimport { register } from '@formkit/dev';\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar vueBindings, bindings_default;\nvar init_bindings = __esm({\n  \"packages/vue/src/bindings.ts\"() {\n    vueBindings = function vueBindings2(node) {\n      node.ledger.count(\"blocking\", (m) => m.blocking);\n      const isValid = ref(!node.ledger.value(\"blocking\"));\n      node.ledger.count(\"errors\", (m) => m.type === \"error\");\n      const hasErrors = ref(!!node.ledger.value(\"errors\"));\n      let hasTicked = false;\n      nextTick(() => {\n        hasTicked = true;\n      });\n      const availableMessages = reactive(\n        node.store.reduce((store, message3) => {\n          if (message3.visible) {\n            store[message3.key] = message3;\n          }\n          return store;\n        }, {})\n      );\n      const validationVisibility = ref(\n        node.props.validationVisibility || (node.props.type === \"checkbox\" ? \"dirty\" : \"blur\")\n      );\n      node.on(\"prop:validationVisibility\", ({ payload }) => {\n        validationVisibility.value = payload;\n      });\n      const hasShownErrors = ref(validationVisibility.value === \"live\");\n      const isRequired = ref(false);\n      const checkForRequired = (parsedRules) => {\n        isRequired.value = (parsedRules ?? []).some(\n          (rule) => rule.name === \"required\"\n        );\n      };\n      checkForRequired(node.props.parsedRules);\n      node.on(\"prop:parsedRules\", ({ payload }) => checkForRequired(payload));\n      const items = ref(node.children.map((child) => child.uid));\n      const validationVisible = computed(() => {\n        if (!context.state)\n          return false;\n        if (context.state.submitted)\n          return true;\n        if (!hasShownErrors.value && !context.state.settled) {\n          return false;\n        }\n        switch (validationVisibility.value) {\n          case \"live\":\n            return true;\n          case \"blur\":\n            return context.state.blurred;\n          case \"dirty\":\n            return context.state.dirty;\n          default:\n            return false;\n        }\n      });\n      const isComplete = computed(() => {\n        return context && hasValidation.value ? isValid.value && !hasErrors.value : context.state.dirty && !empty(context.value);\n      });\n      const hasValidation = ref(\n        Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0\n      );\n      node.on(\"prop:parsedRules\", ({ payload: rules }) => {\n        hasValidation.value = Array.isArray(rules) && rules.length > 0;\n      });\n      const messages3 = computed(() => {\n        const visibleMessages = {};\n        for (const key in availableMessages) {\n          const message3 = availableMessages[key];\n          if (message3.type !== \"validation\" || validationVisible.value) {\n            visibleMessages[key] = message3;\n          }\n        }\n        return visibleMessages;\n      });\n      const ui = reactive(\n        node.store.reduce((messages4, message3) => {\n          if (message3.type === \"ui\" && message3.visible)\n            messages4[message3.key] = message3;\n          return messages4;\n        }, {})\n      );\n      const cachedClasses = reactive({});\n      const classes2 = new Proxy(cachedClasses, {\n        get(...args) {\n          const [target, property] = args;\n          let className = Reflect.get(...args);\n          if (!className && typeof property === \"string\") {\n            if (!has(target, property) && !property.startsWith(\"__v\")) {\n              const observedNode = createObserver(node);\n              observedNode.watch((node2) => {\n                const rootClasses = typeof node2.config.rootClasses === \"function\" ? node2.config.rootClasses(property, node2) : {};\n                const globalConfigClasses = node2.config.classes ? createClasses(property, node2, node2.config.classes[property]) : {};\n                const classesPropClasses = createClasses(\n                  property,\n                  node2,\n                  node2.props[`_${property}Class`]\n                );\n                const sectionPropClasses = createClasses(\n                  property,\n                  node2,\n                  node2.props[`${property}Class`]\n                );\n                className = generateClassList(\n                  node2,\n                  property,\n                  rootClasses,\n                  globalConfigClasses,\n                  classesPropClasses,\n                  sectionPropClasses\n                );\n                target[property] = className ?? \"\";\n              });\n            }\n          }\n          return className;\n        }\n      });\n      node.on(\"prop:rootClasses\", () => {\n        const keys = Object.keys(cachedClasses);\n        for (const key of keys) {\n          delete cachedClasses[key];\n        }\n      });\n      const describedBy = computed(() => {\n        const describers = [];\n        if (context.help) {\n          describers.push(`help-${node.props.id}`);\n        }\n        for (const key in messages3.value) {\n          describers.push(`${node.props.id}-${key}`);\n        }\n        return describers.length ? describers.join(\" \") : void 0;\n      });\n      const value = ref(node.value);\n      const _value = ref(node.value);\n      const context = reactive({\n        _value,\n        attrs: node.props.attrs,\n        disabled: node.props.disabled,\n        describedBy,\n        fns: {\n          length: (obj) => Object.keys(obj).length,\n          number: (value2) => Number(value2),\n          string: (value2) => String(value2),\n          json: (value2) => JSON.stringify(value2),\n          eq: eq\n        },\n        handlers: {\n          blur: (e) => {\n            if (!node)\n              return;\n            node.store.set(\n              createMessage({ key: \"blurred\", visible: false, value: true })\n            );\n            if (typeof node.props.attrs.onBlur === \"function\") {\n              node.props.attrs.onBlur(e);\n            }\n          },\n          touch: () => {\n            const doCompare = context.dirtyBehavior === \"compare\";\n            if (node.store.dirty?.value && !doCompare)\n              return;\n            const isDirty = !eq(node.props._init, node._value);\n            if (!isDirty && !doCompare)\n              return;\n            node.store.set(\n              createMessage({ key: \"dirty\", visible: false, value: isDirty })\n            );\n          },\n          DOMInput: (e) => {\n            node.input(e.target.value);\n            node.emit(\"dom-input-event\", e);\n          }\n        },\n        help: node.props.help,\n        id: node.props.id,\n        items,\n        label: node.props.label,\n        messages: messages3,\n        didMount: false,\n        node: markRaw(node),\n        options: node.props.options,\n        defaultMessagePlacement: true,\n        slots: node.props.__slots,\n        state: {\n          blurred: false,\n          complete: isComplete,\n          dirty: false,\n          empty: empty(value),\n          submitted: false,\n          settled: node.isSettled,\n          valid: isValid,\n          errors: hasErrors,\n          rules: hasValidation,\n          validationVisible,\n          required: isRequired\n        },\n        type: node.props.type,\n        family: node.props.family,\n        ui,\n        value,\n        classes: classes2\n      });\n      node.on(\"created\", () => {\n        if (!eq(context.value, node.value)) {\n          _value.value = node.value;\n          value.value = node.value;\n          triggerRef(value);\n          triggerRef(_value);\n        }\n        (async () => {\n          await node.settled;\n          if (node)\n            node.props._init = cloneAny(node.value);\n        })();\n      });\n      node.on(\"mounted\", () => {\n        context.didMount = true;\n      });\n      node.on(\"settled\", ({ payload: isSettled }) => {\n        context.state.settled = isSettled;\n      });\n      function observeProps(observe) {\n        const propNames = Array.isArray(observe) ? observe : Object.keys(observe);\n        propNames.forEach((prop) => {\n          prop = camel(prop);\n          if (!has(context, prop)) {\n            context[prop] = node.props[prop];\n          }\n          node.on(`prop:${prop}`, ({ payload }) => {\n            context[prop] = payload;\n          });\n        });\n      }\n      const rootProps = () => {\n        const props = [\n          \"__root\",\n          \"help\",\n          \"label\",\n          \"disabled\",\n          \"options\",\n          \"type\",\n          \"attrs\",\n          \"preserve\",\n          \"preserveErrors\",\n          \"id\",\n          \"dirtyBehavior\"\n        ];\n        const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/;\n        const matchingProps = Object.keys(node.props).filter((prop) => {\n          return iconPattern.test(prop);\n        });\n        return props.concat(matchingProps);\n      };\n      observeProps(rootProps());\n      function definedAs(definition3) {\n        if (definition3.props)\n          observeProps(definition3.props);\n      }\n      node.props.definition && definedAs(node.props.definition);\n      node.on(\"added-props\", ({ payload }) => observeProps(payload));\n      node.on(\"input\", ({ payload }) => {\n        if (node.type !== \"input\" && !isRef(payload) && !isReactive(payload)) {\n          _value.value = shallowClone(payload);\n        } else {\n          _value.value = payload;\n          triggerRef(_value);\n        }\n      });\n      node.on(\"commitRaw\", ({ payload }) => {\n        if (node.type !== \"input\" && !isRef(payload) && !isReactive(payload)) {\n          value.value = _value.value = shallowClone(payload);\n        } else {\n          value.value = _value.value = payload;\n          triggerRef(value);\n        }\n        node.emit(\"modelUpdated\");\n      });\n      node.on(\"commit\", ({ payload }) => {\n        if ((!context.state.dirty || context.dirtyBehavior === \"compare\") && node.isCreated && hasTicked) {\n          if (!node.store.validating?.value) {\n            context.handlers.touch();\n          } else {\n            const receipt = node.on(\"message-removed\", ({ payload: message3 }) => {\n              if (message3.key === \"validating\") {\n                context.handlers.touch();\n                node.off(receipt);\n              }\n            });\n          }\n        }\n        if (isComplete && node.type === \"input\" && hasErrors.value && !undefine(node.props.preserveErrors)) {\n          node.store.filter(\n            (message3) => !(message3.type === \"error\" && message3.meta?.autoClear === true)\n          );\n        }\n        if (node.type === \"list\" && node.sync) {\n          items.value = node.children.map((child) => child.uid);\n        }\n        context.state.empty = empty(payload);\n      });\n      const updateState = async (message3) => {\n        if (message3.type === \"ui\" && message3.visible && !message3.meta.showAsMessage) {\n          ui[message3.key] = message3;\n        } else if (message3.visible) {\n          availableMessages[message3.key] = message3;\n        } else if (message3.type === \"state\") {\n          context.state[message3.key] = !!message3.value;\n        }\n      };\n      node.on(\"message-added\", (e) => updateState(e.payload));\n      node.on(\"message-updated\", (e) => updateState(e.payload));\n      node.on(\"message-removed\", ({ payload: message3 }) => {\n        delete ui[message3.key];\n        delete availableMessages[message3.key];\n        delete context.state[message3.key];\n      });\n      node.on(\"settled:blocking\", () => {\n        isValid.value = true;\n      });\n      node.on(\"unsettled:blocking\", () => {\n        isValid.value = false;\n      });\n      node.on(\"settled:errors\", () => {\n        hasErrors.value = false;\n      });\n      node.on(\"unsettled:errors\", () => {\n        hasErrors.value = true;\n      });\n      watch(validationVisible, (value2) => {\n        if (value2) {\n          hasShownErrors.value = true;\n        }\n      });\n      node.context = context;\n      node.emit(\"context\", node, false);\n      node.on(\"destroyed\", () => {\n        node.context = void 0;\n        node = null;\n      });\n    };\n    bindings_default = vueBindings;\n  }\n});\n\n// packages/vue/src/defaultConfig.ts\nvar defaultConfig_exports = {};\n__export(defaultConfig_exports, {\n  defaultConfig: () => defaultConfig\n});\nvar defaultConfig;\nvar init_defaultConfig = __esm({\n  \"packages/vue/src/defaultConfig.ts\"() {\n    init_bindings();\n    defaultConfig = (options = {}) => {\n      register();\n      const {\n        rules = {},\n        locales = {},\n        inputs: inputs$1 = {},\n        messages: messages3 = {},\n        locale = void 0,\n        theme = void 0,\n        iconLoaderUrl = void 0,\n        iconLoader = void 0,\n        icons = {},\n        ...nodeOptions\n      } = options;\n      const validation = createValidationPlugin({\n        ...defaultRules,\n        ...rules || {}\n      });\n      const i18n = createI18nPlugin(\n        extend({ en, ...locales || {} }, messages3)\n      );\n      const library = createLibraryPlugin(inputs, inputs$1);\n      const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader);\n      return extend(\n        {\n          plugins: [library, themePlugin, bindings_default, i18n, validation],\n          ...!locale ? {} : { config: { locale } }\n        },\n        nodeOptions || {},\n        true\n      );\n    };\n  }\n});\n\n// packages/vue/src/composables/onSSRComplete.ts\nvar isServer = typeof window === \"undefined\";\nvar ssrCompleteRegistry = /* @__PURE__ */ new Map();\nfunction ssrComplete(app) {\n  if (!isServer)\n    return;\n  const callbacks = ssrCompleteRegistry.get(app);\n  if (!callbacks)\n    return;\n  for (const callback of callbacks) {\n    callback();\n  }\n  callbacks.clear();\n  ssrCompleteRegistry.delete(app);\n}\nfunction onSSRComplete(app, callback) {\n  if (!isServer || !app)\n    return;\n  if (!ssrCompleteRegistry.has(app))\n    ssrCompleteRegistry.set(app, /* @__PURE__ */ new Set());\n  ssrCompleteRegistry.get(app)?.add(callback);\n}\n\n// packages/vue/src/FormKitSchema.ts\nvar isServer2 = typeof window === \"undefined\";\nvar memo = {};\nvar memoKeys = {};\nvar instanceKey;\nvar instanceScopes = /* @__PURE__ */ new WeakMap();\nvar raw = \"__raw__\";\nvar isClassProp = /[a-zA-Z0-9\\-][cC]lass$/;\nfunction getRef(token3, data) {\n  const value = ref(null);\n  if (token3 === \"get\") {\n    const nodeRefs = {};\n    value.value = get.bind(null, nodeRefs);\n    return value;\n  }\n  const path = token3.split(\".\");\n  watchEffect(() => {\n    value.value = getValue(\n      isRef(data) ? data.value : data,\n      path\n    );\n  });\n  return value;\n}\nfunction getValue(set, path) {\n  if (Array.isArray(set)) {\n    for (const subset of set) {\n      const value = subset !== false && getValue(subset, path);\n      if (value !== void 0)\n        return value;\n    }\n    return void 0;\n  }\n  let foundValue = void 0;\n  let obj = set;\n  for (const i in path) {\n    const key = path[i];\n    if (typeof obj !== \"object\" || obj === null) {\n      foundValue = void 0;\n      break;\n    }\n    const currentValue = obj[key];\n    if (Number(i) === path.length - 1 && currentValue !== void 0) {\n      foundValue = typeof currentValue === \"function\" ? currentValue.bind(obj) : currentValue;\n      break;\n    }\n    obj = currentValue;\n  }\n  return foundValue;\n}\nfunction get(nodeRefs, id) {\n  if (typeof id !== \"string\")\n    return warn(650);\n  if (!(id in nodeRefs))\n    nodeRefs[id] = ref(void 0);\n  if (nodeRefs[id].value === void 0) {\n    nodeRefs[id].value = null;\n    const root = getNode(id);\n    if (root)\n      nodeRefs[id].value = root.context;\n    watchRegistry(id, ({ payload: node }) => {\n      nodeRefs[id].value = isNode(node) ? node.context : node;\n    });\n  }\n  return nodeRefs[id].value;\n}\nfunction parseSchema(library, schema, memoKey) {\n  function parseCondition(library2, node) {\n    const condition = provider(compile(node.if), { if: true });\n    const children = createElements(library2, node.then);\n    const alternate = node.else ? createElements(library2, node.else) : null;\n    return [condition, children, alternate];\n  }\n  function parseConditionAttr(attr, _default) {\n    const condition = provider(compile(attr.if));\n    let b = () => _default;\n    let a = () => _default;\n    if (typeof attr.then === \"object\") {\n      a = parseAttrs(attr.then, void 0);\n    } else if (typeof attr.then === \"string\" && attr.then?.startsWith(\"$\")) {\n      a = provider(compile(attr.then));\n    } else {\n      a = () => attr.then;\n    }\n    if (has(attr, \"else\")) {\n      if (typeof attr.else === \"object\") {\n        b = parseAttrs(attr.else);\n      } else if (typeof attr.else === \"string\" && attr.else?.startsWith(\"$\")) {\n        b = provider(compile(attr.else));\n      } else {\n        b = () => attr.else;\n      }\n    }\n    return () => condition() ? a() : b();\n  }\n  function parseAttrs(unparsedAttrs, bindExp, _default = {}) {\n    const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));\n    const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});\n    const setters = [\n      (attrs) => {\n        const bound = boundAttrs();\n        for (const attr in bound) {\n          if (!explicitAttrs.has(attr)) {\n            attrs[attr] = bound[attr];\n          }\n        }\n      }\n    ];\n    if (unparsedAttrs) {\n      if (isConditional(unparsedAttrs)) {\n        const condition = parseConditionAttr(\n          unparsedAttrs,\n          _default\n        );\n        return condition;\n      }\n      for (let attr in unparsedAttrs) {\n        const value = unparsedAttrs[attr];\n        let getValue2;\n        const isStr = typeof value === \"string\";\n        if (attr.startsWith(raw)) {\n          attr = attr.substring(7);\n          getValue2 = () => value;\n        } else if (isStr && value.startsWith(\"$\") && value.length > 1 && !(value.startsWith(\"$reset\") && isClassProp.test(attr))) {\n          getValue2 = provider(compile(value));\n        } else if (typeof value === \"object\" && isConditional(value)) {\n          getValue2 = parseConditionAttr(value, void 0);\n        } else if (typeof value === \"object\" && isPojo(value)) {\n          getValue2 = parseAttrs(value);\n        } else {\n          getValue2 = () => value;\n        }\n        setters.push((attrs) => {\n          attrs[attr] = getValue2();\n        });\n      }\n    }\n    return () => {\n      const attrs = Array.isArray(unparsedAttrs) ? [] : {};\n      setters.forEach((setter) => setter(attrs));\n      return attrs;\n    };\n  }\n  function parseNode(library2, _node) {\n    let element = null;\n    let attrs = () => null;\n    let condition = false;\n    let children = null;\n    let alternate = null;\n    let iterator = null;\n    let resolve = false;\n    const node = sugar(_node);\n    if (isDOM(node)) {\n      element = node.$el;\n      attrs = node.$el !== \"text\" ? parseAttrs(node.attrs, node.bind) : () => null;\n    } else if (isComponent(node)) {\n      if (typeof node.$cmp === \"string\") {\n        if (has(library2, node.$cmp)) {\n          element = library2[node.$cmp];\n        } else {\n          element = node.$cmp;\n          resolve = true;\n        }\n      } else {\n        element = node.$cmp;\n      }\n      attrs = parseAttrs(node.props, node.bind);\n    } else if (isConditional(node)) {\n      [condition, children, alternate] = parseCondition(library2, node);\n    }\n    if (!isConditional(node) && \"if\" in node) {\n      condition = provider(compile(node.if));\n    } else if (!isConditional(node) && element === null) {\n      condition = () => true;\n    }\n    if (\"children\" in node && node.children) {\n      if (typeof node.children === \"string\") {\n        if (node.children.startsWith(\"$slots.\")) {\n          element = element === \"text\" ? \"slot\" : element;\n          children = provider(compile(node.children));\n        } else if (node.children.startsWith(\"$\") && node.children.length > 1) {\n          const value = provider(compile(node.children));\n          children = () => String(value());\n        } else {\n          children = () => String(node.children);\n        }\n      } else if (Array.isArray(node.children)) {\n        children = createElements(library2, node.children);\n      } else {\n        const [childCondition, c, a] = parseCondition(library2, node.children);\n        children = (iterationData) => childCondition && childCondition() ? c && c(iterationData) : a && a(iterationData);\n      }\n    }\n    if (isComponent(node)) {\n      if (children) {\n        const produceChildren = children;\n        children = (iterationData) => {\n          return {\n            default(slotData2, key) {\n              const currentKey = instanceKey;\n              if (key)\n                instanceKey = key;\n              if (slotData2)\n                instanceScopes.get(instanceKey)?.unshift(slotData2);\n              if (iterationData)\n                instanceScopes.get(instanceKey)?.unshift(iterationData);\n              const c = produceChildren(iterationData);\n              if (slotData2)\n                instanceScopes.get(instanceKey)?.shift();\n              if (iterationData)\n                instanceScopes.get(instanceKey)?.shift();\n              instanceKey = currentKey;\n              return c;\n            }\n          };\n        };\n        children.slot = true;\n      } else {\n        children = () => ({});\n      }\n    }\n    if (\"for\" in node && node.for) {\n      const values = node.for.length === 3 ? node.for[2] : node.for[1];\n      const getValues = typeof values === \"string\" && values.startsWith(\"$\") ? provider(compile(values)) : () => values;\n      iterator = [\n        getValues,\n        node.for[0],\n        node.for.length === 3 ? String(node.for[1]) : null\n      ];\n    }\n    return [condition, element, attrs, children, alternate, iterator, resolve];\n  }\n  function createSlots(children, iterationData) {\n    const slots = children(iterationData);\n    const currentKey = instanceKey;\n    return Object.keys(slots).reduce((allSlots, slotName) => {\n      const slotFn = slots && slots[slotName];\n      allSlots[slotName] = (data) => {\n        return slotFn && slotFn(data, currentKey) || null;\n      };\n      return allSlots;\n    }, {});\n  }\n  function createElement(library2, node) {\n    const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library2, node);\n    let createNodes = (iterationData) => {\n      if (condition && element === null && children) {\n        return condition() ? children(iterationData) : alternate && alternate(iterationData);\n      }\n      if (element && (!condition || condition())) {\n        if (element === \"text\" && children) {\n          return createTextVNode(String(children()));\n        }\n        if (element === \"slot\" && children)\n          return children(iterationData);\n        const el = resolve ? resolveComponent(element) : element;\n        const slots = children?.slot ? createSlots(children, iterationData) : null;\n        return h(\n          el,\n          attrs(),\n          slots || (children ? children(iterationData) : [])\n        );\n      }\n      return typeof alternate === \"function\" ? alternate(iterationData) : alternate;\n    };\n    if (iterator) {\n      const repeatedNode = createNodes;\n      const [getValues, valueName, keyName] = iterator;\n      createNodes = () => {\n        const _v = getValues();\n        const values = Number.isFinite(_v) ? Array(Number(_v)).fill(0).map((_, i) => i) : _v;\n        const fragment = [];\n        if (typeof values !== \"object\")\n          return null;\n        const instanceScope = instanceScopes.get(instanceKey) || [];\n        const isArray = Array.isArray(values);\n        for (const key in values) {\n          if (isArray && key in Array.prototype)\n            continue;\n          const iterationData = Object.defineProperty(\n            {\n              ...instanceScope.reduce(\n                (previousIterationData, scopedData) => {\n                  if (previousIterationData.__idata) {\n                    return { ...previousIterationData, ...scopedData };\n                  }\n                  return scopedData;\n                },\n                {}\n              ),\n              [valueName]: values[key],\n              ...keyName !== null ? { [keyName]: isArray ? Number(key) : key } : {}\n            },\n            \"__idata\",\n            { enumerable: false, value: true }\n          );\n          instanceScope.unshift(iterationData);\n          fragment.push(repeatedNode.bind(null, iterationData)());\n          instanceScope.shift();\n        }\n        return fragment;\n      };\n    }\n    return createNodes;\n  }\n  function createElements(library2, schema2) {\n    if (Array.isArray(schema2)) {\n      const els = schema2.map(createElement.bind(null, library2));\n      return (iterationData) => els.map((element2) => element2(iterationData));\n    }\n    const element = createElement(library2, schema2);\n    return (iterationData) => element(iterationData);\n  }\n  const providers = [];\n  function provider(compiled, hints = {}) {\n    const compiledFns = /* @__PURE__ */ new WeakMap();\n    providers.push((callback, key) => {\n      compiledFns.set(\n        key,\n        compiled.provide((tokens) => callback(tokens, hints))\n      );\n    });\n    return () => compiledFns.get(instanceKey)();\n  }\n  function createInstance(providerCallback, key) {\n    memoKey ?? (memoKey = toMemoKey(schema));\n    const [render, compiledProviders] = has(memo, memoKey) ? memo[memoKey] : [createElements(library, schema), providers];\n    if (!isServer2) {\n      memoKeys[memoKey] ?? (memoKeys[memoKey] = 0);\n      memoKeys[memoKey]++;\n      memo[memoKey] = [render, compiledProviders];\n    }\n    compiledProviders.forEach((compiledProvider) => {\n      compiledProvider(providerCallback, key);\n    });\n    return () => {\n      instanceKey = key;\n      return render();\n    };\n  }\n  return createInstance;\n}\nfunction useScope(token3, defaultValue) {\n  const scopedData = instanceScopes.get(instanceKey) || [];\n  let scopedValue = void 0;\n  if (scopedData.length) {\n    scopedValue = getValue(scopedData, token3.split(\".\"));\n  }\n  return scopedValue === void 0 ? defaultValue : scopedValue;\n}\nfunction slotData(data, key) {\n  return new Proxy(data, {\n    get(...args) {\n      let data2 = void 0;\n      const property = args[1];\n      if (typeof property === \"string\") {\n        const prevKey = instanceKey;\n        instanceKey = key;\n        data2 = useScope(property, void 0);\n        instanceKey = prevKey;\n      }\n      return data2 !== void 0 ? data2 : Reflect.get(...args);\n    }\n  });\n}\nfunction createRenderFn(instanceCreator, data, instanceKey2) {\n  return instanceCreator(\n    (requirements, hints = {}) => {\n      return requirements.reduce((tokens, token3) => {\n        if (token3.startsWith(\"slots.\")) {\n          const slot = token3.substring(6);\n          const hasSlot = () => data.slots && has(data.slots, slot) && typeof data.slots[slot] === \"function\";\n          if (hints.if) {\n            tokens[token3] = hasSlot;\n          } else if (data.slots) {\n            const scopedData = slotData(data, instanceKey2);\n            tokens[token3] = () => hasSlot() ? data.slots[slot](scopedData) : null;\n          }\n        } else {\n          const value = getRef(token3, data);\n          tokens[token3] = () => useScope(token3, value.value);\n        }\n        return tokens;\n      }, {});\n    },\n    instanceKey2\n  );\n}\nfunction clean(schema, memoKey, instanceKey2) {\n  memoKey ?? (memoKey = toMemoKey(schema));\n  memoKeys[memoKey]--;\n  if (memoKeys[memoKey] === 0) {\n    delete memoKeys[memoKey];\n    const [, providers] = memo[memoKey];\n    delete memo[memoKey];\n    providers.length = 0;\n  }\n  instanceScopes.delete(instanceKey2);\n}\nfunction toMemoKey(schema) {\n  return JSON.stringify(schema, (_, value) => {\n    if (typeof value === \"function\") {\n      return value.toString();\n    }\n    return value;\n  });\n}\nvar FormKitSchema = /* @__PURE__ */ defineComponent({\n  name: \"FormKitSchema\",\n  props: {\n    schema: {\n      type: [Array, Object],\n      required: true\n    },\n    data: {\n      type: Object,\n      default: () => ({})\n    },\n    library: {\n      type: Object,\n      default: () => ({})\n    },\n    memoKey: {\n      type: String,\n      required: false\n    }\n  },\n  emits: [\"mounted\"],\n  setup(props, context) {\n    const instance = getCurrentInstance();\n    let instanceKey2 = {};\n    instanceScopes.set(instanceKey2, []);\n    const library = { FormKit: markRaw(FormKit_default), ...props.library };\n    let provider = parseSchema(library, props.schema, props.memoKey);\n    let render;\n    let data;\n    if (!isServer2) {\n      watch(\n        () => props.schema,\n        (newSchema, oldSchema) => {\n          const oldKey = instanceKey2;\n          instanceKey2 = {};\n          instanceScopes.set(instanceKey2, []);\n          provider = parseSchema(library, props.schema, props.memoKey);\n          render = createRenderFn(provider, data, instanceKey2);\n          if (newSchema === oldSchema) {\n            (instance?.proxy?.$forceUpdate)();\n          }\n          clean(props.schema, props.memoKey, oldKey);\n        },\n        { deep: true }\n      );\n    }\n    watchEffect(() => {\n      data = Object.assign(reactive(props.data ?? {}), {\n        slots: context.slots\n      });\n      context.slots;\n      render = createRenderFn(provider, data, instanceKey2);\n    });\n    function cleanUp() {\n      clean(props.schema, props.memoKey, instanceKey2);\n      if (data.node)\n        data.node.destroy();\n      data.slots = null;\n      data = null;\n      render = null;\n    }\n    onMounted(() => context.emit(\"mounted\"));\n    onUnmounted(cleanUp);\n    onSSRComplete(getCurrentInstance()?.appContext.app, cleanUp);\n    return () => render ? render() : null;\n  }\n});\nvar FormKitSchema_default = FormKitSchema;\nvar isServer3 = typeof window === \"undefined\";\nvar parentSymbol = Symbol(\"FormKitParent\");\nvar componentSymbol = Symbol(\"FormKitComponentCallback\");\nvar currentSchemaNode = null;\nvar getCurrentSchemaNode = () => currentSchemaNode;\nfunction FormKit(props, context) {\n  const node = useInput(props, context);\n  if (!node.props.definition)\n    error(600, node);\n  if (node.props.definition.component) {\n    return () => h(\n      node.props.definition?.component,\n      {\n        context: node.context\n      },\n      { ...context.slots }\n    );\n  }\n  const schema = ref([]);\n  let memoKey = node.props.definition.schemaMemoKey;\n  const generateSchema = () => {\n    const schemaDefinition = node.props?.definition?.schema;\n    if (!schemaDefinition)\n      error(601, node);\n    if (typeof schemaDefinition === \"function\") {\n      currentSchemaNode = node;\n      schema.value = schemaDefinition({ ...props.sectionsSchema || {} });\n      currentSchemaNode = null;\n      if (memoKey && props.sectionsSchema || \"memoKey\" in schemaDefinition && typeof schemaDefinition.memoKey === \"string\") {\n        memoKey = (memoKey ?? schemaDefinition?.memoKey) + JSON.stringify(props.sectionsSchema);\n      }\n    } else {\n      schema.value = schemaDefinition;\n    }\n  };\n  generateSchema();\n  if (!isServer3) {\n    node.on(\"schema\", () => {\n      memoKey += \"♻️\";\n      generateSchema();\n    });\n  }\n  context.emit(\"node\", node);\n  const definitionLibrary = node.props.definition.library;\n  const library = {\n    FormKit: markRaw(formkitComponent),\n    ...definitionLibrary\n  };\n  function didMount() {\n    node.emit(\"mounted\");\n  }\n  context.expose({ node });\n  return () => h(\n    FormKitSchema,\n    {\n      schema: schema.value,\n      data: node.context,\n      onMounted: didMount,\n      library,\n      memoKey\n    },\n    { ...context.slots }\n  );\n}\nvar formkitComponent = /* @__PURE__ */ defineComponent(\n  FormKit,\n  {\n    props: runtimeProps,\n    inheritAttrs: false\n  }\n);\nvar FormKit_default = formkitComponent;\nvar rootSymbol = Symbol();\nvar FormKitRoot = /* @__PURE__ */ defineComponent((_p, context) => {\n  const boundary = ref(null);\n  const showBody = ref(false);\n  const shadowRoot = ref(void 0);\n  const stopWatch = watch(boundary, (el) => {\n    let parent = el;\n    let root = null;\n    while (parent = parent?.parentNode) {\n      root = parent;\n      if (root instanceof ShadowRoot || root instanceof Document) {\n        foundRoot(root);\n        break;\n      }\n    }\n    stopWatch();\n    showBody.value = true;\n  });\n  provide(rootSymbol, shadowRoot);\n  function foundRoot(root) {\n    shadowRoot.value = root;\n  }\n  return () => showBody.value && context.slots.default ? context.slots.default() : h(\"template\", { ref: boundary });\n});\nfunction createPlugin(app, options) {\n  app.component(options.alias || \"FormKit\", FormKit_default).component(options.schemaAlias || \"FormKitSchema\", FormKitSchema_default);\n  return {\n    get: getNode,\n    setLocale: (locale) => {\n      if (options.config?.rootConfig) {\n        options.config.rootConfig.locale = locale;\n      }\n    },\n    clearErrors,\n    setErrors,\n    submit: submitForm,\n    reset\n  };\n}\nvar optionsSymbol = Symbol.for(\"FormKitOptions\");\nvar configSymbol = Symbol.for(\"FormKitConfig\");\nvar plugin = {\n  install(app, _options) {\n    const options = Object.assign(\n      {\n        alias: \"FormKit\",\n        schemaAlias: \"FormKitSchema\"\n      },\n      typeof _options === \"function\" ? _options() : _options\n    );\n    const rootConfig = createConfig(options.config || {});\n    options.config = { rootConfig };\n    app.config.globalProperties.$formkit = createPlugin(app, options);\n    app.provide(optionsSymbol, options);\n    app.provide(configSymbol, rootConfig);\n    if (typeof window !== \"undefined\") {\n      globalThis.__FORMKIT_CONFIGS__ = (globalThis.__FORMKIT_CONFIGS__ || []).concat([rootConfig]);\n    }\n  }\n};\n\n// packages/vue/src/composables/useInput.ts\nvar isBrowser = typeof window !== \"undefined\";\nvar pseudoProps = [\n  // Boolean props\n  \"ignore\",\n  \"disabled\",\n  \"preserve\",\n  // String props\n  \"help\",\n  \"label\",\n  /^preserve(-e|E)rrors/,\n  /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/,\n  /^[a-zA-Z-]+(?:-class|Class)$/,\n  \"prefixIcon\",\n  \"suffixIcon\",\n  /^[a-zA-Z-]+(?:-icon|Icon)$/\n];\nvar boolProps = [\"disabled\", \"ignore\", \"preserve\"];\nfunction classesToNodeProps(node, props) {\n  if (props.classes) {\n    Object.keys(props.classes).forEach(\n      (key) => {\n        if (typeof key === \"string\") {\n          node.props[`_${key}Class`] = props.classes[key];\n          if (isObject(props.classes[key]) && key === \"inner\")\n            Object.values(props.classes[key]);\n        }\n      }\n    );\n  }\n}\nfunction onlyListeners(props) {\n  if (!props)\n    return {};\n  const knownListeners = [\"Submit\", \"SubmitRaw\", \"SubmitInvalid\"].reduce(\n    (listeners, listener) => {\n      const name = `on${listener}`;\n      if (name in props) {\n        if (typeof props[name] === \"function\") {\n          listeners[name] = props[name];\n        }\n      }\n      return listeners;\n    },\n    {}\n  );\n  return knownListeners;\n}\nfunction useInput(props, context, options = {}) {\n  const config = Object.assign({}, inject(optionsSymbol) || {}, options);\n  const __root = inject(rootSymbol, ref(isBrowser ? document : void 0));\n  const __cmpCallback = inject(componentSymbol, () => {\n  });\n  const instance = getCurrentInstance();\n  const listeners = onlyListeners(instance?.vnode.props);\n  const isVModeled = [\"modelValue\", \"model-value\"].some(\n    (prop) => prop in (instance?.vnode.props ?? {})\n  );\n  let isMounted = false;\n  onMounted(() => {\n    isMounted = true;\n  });\n  const value = props.modelValue !== void 0 ? props.modelValue : cloneAny(context.attrs.value);\n  function createInitialProps() {\n    const initialProps2 = {\n      ...nodeProps(props),\n      ...listeners,\n      type: props.type ?? \"text\",\n      __root: __root.value,\n      __slots: context.slots\n    };\n    const attrs = except(nodeProps(context.attrs), pseudoProps);\n    if (!attrs.key)\n      attrs.key = token();\n    initialProps2.attrs = attrs;\n    const propValues = only(nodeProps(context.attrs), pseudoProps);\n    for (const propName in propValues) {\n      if (boolProps.includes(propName) && propValues[propName] === \"\") {\n        propValues[propName] = true;\n      }\n      initialProps2[camel(propName)] = propValues[propName];\n    }\n    const classesProps = { props: {} };\n    classesToNodeProps(classesProps, props);\n    Object.assign(initialProps2, classesProps.props);\n    if (typeof initialProps2.type !== \"string\") {\n      initialProps2.definition = initialProps2.type;\n      delete initialProps2.type;\n    }\n    return initialProps2;\n  }\n  const initialProps = createInitialProps();\n  const parent = initialProps.ignore ? null : props.parent || inject(parentSymbol, null);\n  const node = createNode(\n    extend(\n      config || {},\n      {\n        name: props.name || void 0,\n        value,\n        parent,\n        plugins: (config.plugins || []).concat(props.plugins ?? []),\n        config: props.config || {},\n        props: initialProps,\n        index: props.index,\n        sync: !!undefine(context.attrs.sync || context.attrs.dynamic)\n      },\n      false,\n      true\n    )\n  );\n  __cmpCallback(node);\n  if (!node.props.definition)\n    error(600, node);\n  const lateBoundProps = ref(\n    new Set(\n      Array.isArray(node.props.__propDefs) ? node.props.__propDefs : Object.keys(node.props.__propDefs ?? {})\n    )\n  );\n  node.on(\n    \"added-props\",\n    ({ payload: lateProps }) => {\n      const propNames = Array.isArray(lateProps) ? lateProps : Object.keys(lateProps ?? {});\n      propNames.forEach((newProp) => lateBoundProps.value.add(newProp));\n    }\n  );\n  const pseudoPropNames = computed(\n    () => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\n      if (typeof prop === \"string\") {\n        names.push(camel(prop));\n        names.push(kebab(prop));\n      } else {\n        names.push(prop);\n      }\n      return names;\n    }, [])\n  );\n  watchEffect(() => classesToNodeProps(node, props));\n  const passThrough = nodeProps(props);\n  for (const prop in passThrough) {\n    watch(\n      () => props[prop],\n      () => {\n        if (props[prop] !== void 0) {\n          node.props[prop] = props[prop];\n        }\n      }\n    );\n  }\n  watchEffect(() => {\n    node.props.__root = __root.value;\n  });\n  const attributeWatchers = /* @__PURE__ */ new Set();\n  const possibleProps = nodeProps(context.attrs);\n  watchEffect(() => {\n    watchAttributes(only(possibleProps, pseudoPropNames.value));\n  });\n  function watchAttributes(attrProps) {\n    attributeWatchers.forEach((stop) => {\n      stop();\n      attributeWatchers.delete(stop);\n    });\n    for (const prop in attrProps) {\n      const camelName = camel(prop);\n      attributeWatchers.add(\n        watch(\n          () => context.attrs[prop],\n          () => {\n            node.props[camelName] = context.attrs[prop];\n          }\n        )\n      );\n    }\n  }\n  watchEffect(() => {\n    const attrs = except(nodeProps(context.attrs), pseudoPropNames.value);\n    if (\"multiple\" in attrs)\n      attrs.multiple = undefine(attrs.multiple);\n    if (typeof attrs.onBlur === \"function\") {\n      attrs.onBlur = oncePerTick(attrs.onBlur);\n    }\n    node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);\n  });\n  watchEffect(() => {\n    const messages3 = (props.errors ?? []).map(\n      (error3) => createMessage({\n        key: slugify(error3),\n        type: \"error\",\n        value: error3,\n        meta: { source: \"prop\" }\n      })\n    );\n    node.store.apply(\n      messages3,\n      (message3) => message3.type === \"error\" && message3.meta.source === \"prop\"\n    );\n  });\n  if (node.type !== \"input\") {\n    const sourceKey = `${node.name}-prop`;\n    watchEffect(() => {\n      const inputErrors = props.inputErrors ?? {};\n      const keys = Object.keys(inputErrors);\n      if (!keys.length)\n        node.clearErrors(true, sourceKey);\n      const messages3 = keys.reduce((messages4, key) => {\n        let value2 = inputErrors[key];\n        if (typeof value2 === \"string\")\n          value2 = [value2];\n        if (Array.isArray(value2)) {\n          messages4[key] = value2.map(\n            (error3) => createMessage({\n              key: error3,\n              type: \"error\",\n              value: error3,\n              meta: { source: sourceKey }\n            })\n          );\n        }\n        return messages4;\n      }, {});\n      node.store.apply(\n        messages3,\n        (message3) => message3.type === \"error\" && message3.meta.source === sourceKey\n      );\n    });\n  }\n  watchEffect(() => Object.assign(node.config, props.config));\n  if (node.type !== \"input\") {\n    provide(parentSymbol, node);\n  }\n  let clonedValueBeforeVmodel = void 0;\n  node.on(\"modelUpdated\", () => {\n    context.emit(\"inputRaw\", node.context?.value, node);\n    if (isMounted) {\n      context.emit(\"input\", node.context?.value, node);\n    }\n    if (isVModeled && node.context) {\n      clonedValueBeforeVmodel = cloneAny(node.value);\n      context.emit(\"update:modelValue\", shallowClone(node.value));\n    }\n  });\n  if (isVModeled) {\n    watch(\n      toRef(props, \"modelValue\"),\n      (value2) => {\n        if (!eq(clonedValueBeforeVmodel, value2)) {\n          node.input(value2, false);\n        }\n      },\n      { deep: true }\n    );\n    if (node.value !== value) {\n      node.emit(\"modelUpdated\");\n    }\n  }\n  onBeforeUnmount(() => node.destroy());\n  return node;\n}\nvar totalCreated = 1;\nfunction isComponent2(obj) {\n  return typeof obj === \"function\" && obj.length === 2 || typeof obj === \"object\" && !Array.isArray(obj) && !(\"$el\" in obj) && !(\"$cmp\" in obj) && !(\"if\" in obj);\n}\nfunction createInput(schemaOrComponent, definitionOptions = {}, sectionsSchema = {}) {\n  const definition3 = {\n    type: \"input\",\n    ...definitionOptions\n  };\n  let schema;\n  if (isComponent2(schemaOrComponent)) {\n    const cmpName = `SchemaComponent${totalCreated++}`;\n    schema = createSection(\"input\", () => ({\n      $cmp: cmpName,\n      props: {\n        context: \"$node.context\"\n      }\n    }));\n    definition3.library = { [cmpName]: markRaw(schemaOrComponent) };\n  } else if (typeof schemaOrComponent === \"function\") {\n    schema = schemaOrComponent;\n  } else {\n    schema = createSection(\"input\", () => cloneAny(schemaOrComponent));\n  }\n  definition3.schema = useSchema(schema || \"Schema undefined\", sectionsSchema);\n  if (!definition3.schemaMemoKey) {\n    definition3.schemaMemoKey = `${Math.random()}`;\n  }\n  return definition3;\n}\n\n// packages/vue/src/composables/defineFormKitConfig.ts\nfunction defineFormKitConfig(config) {\n  return () => typeof config === \"function\" ? config() : config;\n}\nvar inputList = {};\nvar schemas = {};\nvar classes = {\n  container: `\n    formkit-kitchen-sink \n    p-8\n  `,\n  tabs: `\n    formkit-tabs \n    mt-4 \n    mr-[min(350px,25vw)]\n  `,\n  tab: `\n    formkit-kitchen-sink-tab\n    inline-block\n    mb-4\n    -mr-px\n    cursor-pointer\n    px-4\n    py-2\n    border\n    border-neutral-200\n    text-neutral-800\n    data-[active]:bg-neutral-800\n    data-[active]:border-neutral-800\n    data-[active]:text-neutral-50\n    hover:bg-neutral-100\n    hover:text-neutral-900\n    dark:border-neutral-700\n    dark:text-neutral-50\n    dark:data-[active]:bg-neutral-100\n    dark:data-[active]:border-neutral-100\n    dark:data-[active]:text-neutral-800\n    dark:hover:bg-neutral-800\n    dark:hover:text-neutral-50\n  `,\n  filterContainer: `\n    formkit-filter-container\n    grid\n    grid-cols-[repeat(auto-fit,300px)]\n    mr-[min(350px,25vw)]\n    -mt-4\n    mb-8\n    px-4\n    pt-8\n    pb-4\n    border\n    relative\n    -translate-y-px\n    max-w-[1000px]\n    border-neutral-200\n    dark:border-neutral-700\n  `,\n  filterGroup: `\n    formkit-filter-group\n    mr-8\n    mb-8\n    [&_legend]:text-lg\n    [&_ul]:columns-2\n    [&_ul>li:first-child]:[column-span:all]\n    [&_ul>li:first-child]:mt-2\n    [&_ul>li:first-child]:mb-2\n    [&_ul>li:first-child]:pb-2\n    [&_ul>li:first-child]:border-b\n    [&_ul>li:first-child]:border-neutral-200\n    dark:[&_ul>li:first-child]:border-neutral-700\n  `,\n  formContainer: `\n    formkit-form-container\n    w-full\n    bg-white\n    rounded\n    border\n    border-neutral-100\n    shadow-lg\n    max-w-[800px]\n    p-[min(5vw,5rem)]\n    dark:bg-neutral-900\n    dark:border-neutral-800\n    dark:shadow-3xl\n    [&_form>h1]:text-2xl\n    [&_form>h1]:mb-4\n    [&_form>h1]:font-bold\n    [&_form>h1+p]:text-base\n    [&_form>h1+p]:mb-4\n    [&_form>h1+p]:-mt-2\n    [&_form_.double]:flex\n    [&_form_.double>*]:w-1/2\n    [&_form_.double>*:first-child]:mr-2\n    [&_form_.triple]:flex\n    [&_form_.triple>*]:w-1/3\n    [&_form_.triple>*:first-child]:mr-2\n    [&_form_.triple>*:last-child]:ml-2\n  `,\n  inputs: `formkit-inputs`,\n  specimen: `\n    formkit-specimen \n    flex \n    flex-col \n    p-2 \n    max-w-[75vw]\n  `,\n  inputSection: `\n    group/section\n    formkit-input-section \n    mr-[min(325px,25vw)]\n  `,\n  specimenGroup: `\n    formkit-specimen-group\n    grid\n    mb-16\n    grid-cols-[repeat(auto-fit,400px)]\n    group-data-[type=\"transferlist\"]/section:grid-cols-[repeat(auto-fit,650px)]\n    group-data-[type=\"multi-step\"]/section:grid-cols-[repeat(auto-fit,550px)]\n  `,\n  inputType: `\n    formkit-input-type\n    block\n    font-bold\n    text-neutral-900\n    border-b\n    border-neutral-100\n    text-3xl\n    mb-8\n    pb-2\n    capitalize\n    dark:border-neutral-800 \n    dark:text-neutral-50\n  `\n};\nasync function fetchInputList() {\n  const response = await fetch(\n    \"https://raw.githubusercontent.com/formkit/input-schemas/master/index.json\"\n  );\n  const json = await response.json();\n  return json;\n}\nasync function fetchInputSchema(input) {\n  try {\n    const response = await fetch(\n      `https://raw.githubusercontent.com/formkit/input-schemas/master/schemas/${input}.json`\n    );\n    const json = await response.json();\n    return json;\n  } catch (error3) {\n    console.error(error3);\n  }\n}\nvar FormKitKitchenSink = /* @__PURE__ */ defineComponent({\n  name: \"FormKitKitchenSink\",\n  props: {\n    schemas: {\n      type: Array,\n      required: false\n    },\n    pro: {\n      type: Boolean,\n      default: true\n    },\n    addons: {\n      type: Boolean,\n      default: true\n    },\n    forms: {\n      type: Boolean,\n      default: true\n    },\n    navigation: {\n      type: Boolean,\n      default: true\n    }\n  },\n  async setup(props) {\n    onMounted(() => {\n      const filterNode = getNode(\"filter-checkboxes\");\n      data.filters = computed(() => {\n        if (!filterNode?.context)\n          return [];\n        const filters = filterNode.context.value;\n        const filterValues = [];\n        Object.keys(filters).forEach((key) => {\n          filterValues.push(...filters[key]);\n        });\n        return filterValues;\n      });\n    });\n    inputList = Object.keys(inputList).length ? inputList : await fetchInputList();\n    const promises = [];\n    const activeTab = ref(\"\");\n    const inputCheckboxes = computed(() => {\n      const inputGroups = {\n        core: { label: \"Inputs\", name: \"core\", inputs: inputList.core }\n      };\n      if (props.pro) {\n        inputGroups.pro = {\n          label: \"Pro Inputs\",\n          name: \"pro\",\n          inputs: inputList.pro\n        };\n      }\n      if (props.addons) {\n        inputGroups.addons = {\n          label: \"Add-ons\",\n          name: \"addons\",\n          inputs: inputList.addons\n        };\n      }\n      return inputGroups;\n    });\n    if (!props.schemas) {\n      const coreInputPromises = inputList.core.map(async (schema) => {\n        const response = await fetchInputSchema(schema);\n        schemas[schema] = response;\n      });\n      promises.push(...coreInputPromises);\n      if (props.forms) {\n        const formsPromises = inputList.forms.map(async (schema) => {\n          const schemaName = `form/${schema}`;\n          const response = await fetchInputSchema(schemaName);\n          schemas[schemaName] = response;\n        });\n        promises.push(...formsPromises);\n      }\n      if (props.pro) {\n        const proInputPromises = inputList.pro.map(async (schema) => {\n          const response = await fetchInputSchema(schema);\n          schemas[schema] = response;\n        });\n        promises.push(...proInputPromises);\n      }\n      if (props.addons) {\n        const addonPromises = inputList.addons.map(async (schema) => {\n          const response = await fetchInputSchema(schema);\n          schemas[schema] = response;\n        });\n        promises.push(...addonPromises);\n      }\n    } else {\n      const schemaPromises = props.schemas.map(async (schema) => {\n        const response = await fetchInputSchema(`${schema}`);\n        schemas[`${schema}`] = response;\n      });\n      promises.push(...schemaPromises);\n    }\n    const selectAll = (node) => {\n      let previousValue = [];\n      let skip = false;\n      if (node.props.type !== \"checkbox\")\n        return;\n      node.on(\"created\", () => {\n        const currentValue = node.value;\n        if (Array.isArray(currentValue) && currentValue.length === 1 && currentValue[0] === \"all\") {\n          node.input(\n            node.props.options.map((option) => {\n              if (typeof option !== \"string\")\n                return option.value;\n              return option;\n            })\n          );\n        }\n        previousValue = Array.isArray(node.value) ? node.value : [];\n      });\n      node.on(\"commit\", ({ payload }) => {\n        if (skip) {\n          skip = false;\n          return;\n        }\n        if (!Array.isArray(payload))\n          return;\n        const previousValueHadAll = previousValue.includes(\"all\");\n        const currentValueHasAll = payload.includes(\"all\");\n        if (!previousValueHadAll && currentValueHasAll) {\n          const computedOptions = node.props.options.map(\n            (option) => {\n              if (typeof option !== \"string\")\n                return option.value;\n              return option;\n            }\n          );\n          node.input(computedOptions);\n          previousValue = computedOptions;\n          return;\n        }\n        if (previousValueHadAll && !currentValueHasAll) {\n          node.input([]);\n          previousValue = [];\n          return;\n        }\n        const valueMinusAll = payload.filter((value) => value !== \"all\");\n        if (valueMinusAll.length < node.props.options.length - 1 && currentValueHasAll) {\n          node.input(valueMinusAll);\n          previousValue = valueMinusAll;\n          skip = true;\n          return;\n        }\n        if (valueMinusAll.length === node.props.options.length - 1 && !currentValueHasAll) {\n          const computedOptions = node.props.options.map(\n            (option) => {\n              if (typeof option !== \"string\")\n                return option.value;\n              return option;\n            }\n          );\n          node.input(computedOptions);\n          previousValue = Array.isArray(node.value) ? node.value : [];\n          return;\n        }\n      });\n    };\n    const data = reactive({\n      twClasses: classes,\n      basicOptions: Array.from({ length: 15 }, (_, i) => `Option ${i + 1}`),\n      asyncLoader: async () => {\n        return await new Promise(() => {\n        });\n      },\n      paginatedLoader: async ({\n        page,\n        hasNextPage\n      }) => {\n        const base = (page - 1) * 10;\n        hasNextPage();\n        return Array.from({ length: 10 }, (_, i) => `Option ${base + i + 1}`);\n      },\n      formSubmitHandler: async (data2) => {\n        await new Promise((resolve) => setTimeout(resolve, 1e3));\n        alert(\"Form submitted (fake) — check console for data object\");\n        console.log(\"Form data:\", data2);\n      },\n      includes: (array, value) => {\n        if (!Array.isArray(array))\n          return false;\n        return array.includes(value);\n      },\n      checkboxPlugins: [selectAll],\n      filters: []\n    });\n    await Promise.all(promises);\n    const inputKeys = Object.keys(schemas);\n    const formNames = inputKeys.map((key) => {\n      if (key.startsWith(\"form/\")) {\n        switch (key) {\n          case \"form/tshirt\":\n            return {\n              id: key,\n              name: \"Order Form\"\n            };\n          default:\n            const name = key.replace(\"form/\", \"\");\n            return {\n              id: key,\n              name: name.charAt(0).toUpperCase() + name.slice(1) + \" Form\"\n            };\n        }\n      }\n      return {\n        id: key,\n        name: \"\"\n      };\n    });\n    const filteredFormNames = formNames.filter((form) => form.name !== \"\");\n    const forms = inputKeys.filter((schema) => {\n      return schema.startsWith(\"form/\");\n    });\n    const inputs = inputKeys.filter(\n      (schema) => !schema.startsWith(\"form/\")\n    );\n    const tabs = [];\n    if (inputs.length) {\n      tabs.push({\n        id: \"kitchen-sink\",\n        name: \"Kitchen Sink\"\n      });\n    }\n    if (forms.length) {\n      tabs.push(...filteredFormNames.sort((a, b) => a.name > b.name ? 1 : -1));\n    }\n    if (tabs.length) {\n      activeTab.value = tabs[0].id;\n    }\n    const kitchenSinkRenders = computed(() => {\n      inputs.sort();\n      const schemaDefinitions = inputs.reduce(\n        (schemaDefinitions2, inputName) => {\n          const schemaDefinition = schemas[inputName];\n          schemaDefinitions2.push({\n            $el: \"div\",\n            if: '$includes($filters, \"' + inputName + '\")',\n            attrs: {\n              key: inputName,\n              class: \"$twClasses.inputSection\",\n              \"data-type\": inputName\n            },\n            children: [\n              {\n                $el: \"h2\",\n                attrs: {\n                  class: \"$twClasses.inputType\"\n                },\n                children: inputName\n              },\n              {\n                $el: \"div\",\n                attrs: {\n                  class: \"$twClasses.specimenGroup\"\n                },\n                children: [\n                  ...(Array.isArray(schemaDefinition) ? schemaDefinition : [schemaDefinition]).map((specimen) => {\n                    return {\n                      $el: \"div\",\n                      attrs: {\n                        class: \"$twClasses.specimen\"\n                      },\n                      children: [specimen]\n                    };\n                  })\n                ]\n              }\n            ]\n          });\n          return schemaDefinitions2;\n        },\n        []\n      );\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            return activeTab.value === \"kitchen-sink\" ? h(FormKitSchema, { schema: schemaDefinitions, data }) : null;\n          }\n        }\n      );\n    });\n    const formRenders = computed(() => {\n      return filteredFormNames.map((form) => {\n        const schemaDefinition = schemas[form.id];\n        return h(\n          \"div\",\n          {\n            key: form.id\n          },\n          activeTab.value === form.id ? [\n            h(\n              \"div\",\n              {\n                class: classes.formContainer\n              },\n              [\n                h(FormKitSchema, {\n                  schema: schemaDefinition[0],\n                  data\n                })\n              ]\n            )\n          ] : \"\"\n        );\n      }).filter((form) => form.children);\n    });\n    const tabBar = computed(() => {\n      return h(\n        \"div\",\n        {\n          key: \"tab-bar\",\n          class: classes.tabs\n        },\n        tabs.map((tab) => {\n          return h(\n            \"span\",\n            {\n              class: classes.tab,\n              key: tab.id,\n              \"data-tab\": tab.id,\n              \"data-active\": activeTab.value === tab.id || void 0,\n              onClick: () => {\n                activeTab.value = tab.id;\n              }\n            },\n            tab.name\n          );\n        })\n      );\n    });\n    const filterCheckboxes = computed(() => {\n      const createCheckboxSchema = (inputGroup) => {\n        return {\n          $el: \"div\",\n          attrs: {\n            class: \"$twClasses.filterGroup\"\n          },\n          children: [\n            {\n              $formkit: \"checkbox\",\n              name: inputGroup.name,\n              label: inputGroup.label,\n              plugins: \"$checkboxPlugins\",\n              value: [\"all\"],\n              options: [\n                {\n                  label: \"All\",\n                  value: \"all\"\n                },\n                ...Array.isArray(inputGroup.inputs) ? inputGroup.inputs : []\n              ]\n            }\n          ]\n        };\n      };\n      const filterSchema = h(FormKitSchema, {\n        key: \"filter-checkboxes\",\n        data,\n        schema: {\n          $formkit: \"group\",\n          id: \"filter-checkboxes\",\n          children: [\n            {\n              $el: \"div\",\n              attrs: {\n                class: \"$twClasses.filterContainer\"\n              },\n              children: Object.keys(inputCheckboxes.value).map((key) => {\n                const inputGroup = inputCheckboxes.value[key];\n                return createCheckboxSchema(inputGroup);\n              })\n            }\n          ]\n        }\n      });\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            if (!(tabs.find((tab) => tab.id === \"kitchen-sink\") && activeTab.value === \"kitchen-sink\")) {\n              return null;\n            }\n            return filterSchema;\n          }\n        }\n      );\n    });\n    return () => {\n      return h(\n        \"div\",\n        {\n          class: classes.container\n        },\n        [\n          tabs.length > 1 ? tabBar.value : void 0,\n          filterCheckboxes.value,\n          ...formRenders.value,\n          kitchenSinkRenders.value\n        ]\n      );\n    };\n  }\n});\nvar messages = createSection(\"messages\", () => ({\n  $el: \"ul\",\n  if: \"$fns.length($messages)\"\n}));\nvar message = createSection(\"message\", () => ({\n  $el: \"li\",\n  for: [\"message\", \"$messages\"],\n  attrs: {\n    key: \"$message.key\",\n    id: `$id + '-' + $message.key`,\n    \"data-message-type\": \"$message.type\"\n  }\n}));\nvar definition = messages(message(\"$message.value\"));\nvar FormKitMessages = /* @__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object,\n      required: false\n    },\n    sectionsSchema: {\n      type: Object,\n      default: {}\n    },\n    defaultPosition: {\n      type: [String, Boolean],\n      default: false\n    }\n  },\n  setup(props, context) {\n    const node = computed(() => {\n      return props.node || inject(parentSymbol, void 0);\n    });\n    watch(\n      node,\n      () => {\n        if (node.value?.context && !undefine(props.defaultPosition)) {\n          node.value.context.defaultMessagePlacement = false;\n        }\n      },\n      { immediate: true }\n    );\n    const schema = definition(props.sectionsSchema || {});\n    const data = computed(() => {\n      return {\n        messages: node.value?.context?.messages || {},\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {}\n      };\n    });\n    return () => node.value?.context ? h(FormKitSchema_default, { schema, data: data.value }, { ...context.slots }) : null;\n  }\n});\nfunction useConfig(config) {\n  const options = Object.assign(\n    {\n      alias: \"FormKit\",\n      schemaAlias: \"FormKitSchema\"\n    },\n    typeof config === \"function\" ? config() : config\n  );\n  const rootConfig = createConfig(options.config || {});\n  options.config = { rootConfig };\n  provide(optionsSymbol, options);\n  provide(configSymbol, rootConfig);\n  if (typeof window !== \"undefined\") {\n    globalThis.__FORMKIT_CONFIGS__ = (globalThis.__FORMKIT_CONFIGS__ || []).concat([rootConfig]);\n  }\n}\nvar FormKitProvider = /* @__PURE__ */ defineComponent(\n  function FormKitProvider2(props, { slots, attrs }) {\n    const options = {};\n    if (props.config) {\n      useConfig(props.config);\n    }\n    return () => slots.default ? slots.default(options).map((vnode) => {\n      return h(vnode, {\n        ...attrs,\n        ...vnode.props\n      });\n    }) : null;\n  },\n  { props: [\"config\"], name: \"FormKitProvider\", inheritAttrs: false }\n);\nvar FormKitConfigLoader = /* @__PURE__ */ defineComponent(\n  async function FormKitConfigLoader2(props, context) {\n    let config = {};\n    if (props.configFile) {\n      const configFile = await import(\n        /*@__formkit.config.ts__*/\n        /* @vite-ignore */\n        /* webpackIgnore: true */\n        props.configFile\n      );\n      config = \"default\" in configFile ? configFile.default : configFile;\n    }\n    if (typeof config === \"function\") {\n      config = config();\n    }\n    const useDefaultConfig = props.defaultConfig ?? true;\n    if (useDefaultConfig) {\n      const { defaultConfig: defaultConfig2 } = await Promise.resolve().then(() => (init_defaultConfig(), defaultConfig_exports));\n      config = /* @__PURE__ */ defaultConfig2(config);\n    }\n    return () => h(FormKitProvider, { ...context.attrs, config }, context.slots);\n  },\n  {\n    props: [\"defaultConfig\", \"configFile\"],\n    inheritAttrs: false\n  }\n);\nvar FormKitLazyProvider = /* @__PURE__ */ defineComponent(\n  function FormKitLazyProvider2(props, context) {\n    const config = inject(optionsSymbol, null);\n    const passthru = (vnode) => {\n      return h(vnode, {\n        ...context.attrs,\n        ...vnode.props\n      });\n    };\n    if (config) {\n      return () => context.slots?.default ? context.slots.default().map(passthru) : null;\n    }\n    const instance = getCurrentInstance();\n    if (instance.suspense) {\n      return () => h(FormKitConfigLoader, props, {\n        default: () => context.slots?.default ? context.slots.default().map(passthru) : null\n      });\n    }\n    return () => h(Suspense, null, {\n      ...context.slots,\n      default: () => h(FormKitConfigLoader, { ...context.attrs, ...props }, context.slots)\n    });\n  },\n  {\n    props: [\"defaultConfig\", \"configFile\"],\n    inheritAttrs: false\n  }\n);\nvar summary = createSection(\"summary\", () => ({\n  $el: \"div\",\n  attrs: {\n    \"aria-live\": \"polite\"\n  }\n}));\nvar summaryInner = createSection(\"summaryInner\", () => ({\n  $el: \"div\",\n  if: \"$summaries.length && $showSummaries\"\n}));\nvar messages2 = createSection(\"messages\", () => ({\n  $el: \"ul\",\n  if: \"$summaries.length && $showSummaries\"\n}));\nvar message2 = createSection(\"message\", () => ({\n  $el: \"li\",\n  for: [\"summary\", \"$summaries\"],\n  attrs: {\n    key: \"$summary.key\",\n    \"data-message-type\": \"$summary.type\"\n  }\n}));\nvar summaryHeader = createSection(\"summaryHeader\", () => ({\n  $el: \"h2\",\n  attrs: {\n    id: \"$id\"\n  }\n}));\nvar messageLink = createSection(\"messageLink\", () => ({\n  $el: \"a\",\n  attrs: {\n    id: \"$summary.key\",\n    href: '$: \"#\" + $summary.id',\n    onClick: \"$jumpLink\"\n  }\n}));\nvar definition2 = summary(\n  summaryInner(\n    summaryHeader(\"$summaryHeader\"),\n    messages2(message2(messageLink(\"$summary.message\")))\n  )\n);\nvar FormKitSummary = /* @__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object,\n      required: false\n    },\n    forceShow: {\n      type: Boolean,\n      default: false\n    },\n    sectionsSchema: {\n      type: Object,\n      default: {}\n    }\n  },\n  emits: {\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    show: (_summaries) => true\n  },\n  setup(props, context) {\n    const id = `summary-${token()}`;\n    const node = computed(() => {\n      return props.node || inject(parentSymbol, void 0);\n    });\n    if (!node)\n      throw new Error(\n        \"FormKitSummary must have a FormKit parent or use the node prop.\"\n      );\n    const summaryContexts = ref([]);\n    const showSummaries = ref(false);\n    const summaries = computed(() => {\n      const summarizedMessages = [];\n      summaryContexts.value.forEach((context2) => {\n        for (const idx in context2.messages) {\n          const message3 = context2.messages[idx];\n          if (typeof message3.value !== \"string\")\n            continue;\n          summarizedMessages.push({\n            message: message3.value,\n            id: context2.id,\n            key: `${context2.id}-${message3.key}`,\n            type: message3.type\n          });\n        }\n      });\n      return summarizedMessages;\n    });\n    const addContexts = () => {\n      summaryContexts.value = [];\n      node.value?.walk(\n        (child) => child.context && summaryContexts.value.push(child.context)\n      );\n    };\n    node.value?.on(\"submit-raw\", async () => {\n      addContexts();\n      if (summaries.value.length === 0)\n        return;\n      context.emit(\"show\", summaries.value);\n      showSummaries.value = true;\n      await nextTick();\n      if (typeof window !== \"undefined\") {\n        document.getElementById(id)?.scrollIntoView({ behavior: \"smooth\" });\n        if (summaries.value[0]) {\n          document.getElementById(summaries.value[0].key)?.focus();\n        }\n      }\n    });\n    node.value?.on(\"child\", addContexts);\n    function jumpLink(e) {\n      if (e.target instanceof HTMLAnchorElement) {\n        e.preventDefault();\n        const id2 = e.target.getAttribute(\"href\")?.substring(1);\n        if (id2) {\n          document.getElementById(id2)?.scrollIntoView({ behavior: \"smooth\" });\n          document.getElementById(id2)?.focus();\n        }\n      }\n    }\n    localize(\"summaryHeader\", \"There were errors in your form.\")(node.value);\n    const schema = definition2(props.sectionsSchema || {});\n    const data = computed(() => {\n      return {\n        id,\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {},\n        summaries: summaries.value,\n        showSummaries: props.forceShow || showSummaries.value,\n        summaryHeader: node.value?.context?.ui?.summaryHeader?.value || \"\",\n        jumpLink\n      };\n    });\n    return () => node.value?.context ? h(FormKitSchema_default, { schema, data: data.value }, { ...context.slots }) : null;\n  }\n});\n\n// packages/vue/src/index.ts\ninit_defaultConfig();\ninit_bindings();\nvar FormKitIcon = /* @__PURE__ */ defineComponent({\n  name: \"FormKitIcon\",\n  props: {\n    icon: {\n      type: String,\n      default: \"\"\n    },\n    iconLoader: {\n      type: Function,\n      default: null\n    },\n    iconLoaderUrl: {\n      type: Function,\n      default: null\n    }\n  },\n  setup(props) {\n    const icon = ref(void 0);\n    const config = inject(optionsSymbol, {});\n    const parent = inject(parentSymbol, null);\n    let iconHandler = void 0;\n    function loadIcon() {\n      if (!iconHandler || typeof iconHandler !== \"function\")\n        return;\n      const iconOrPromise = iconHandler(props.icon);\n      if (iconOrPromise instanceof Promise) {\n        iconOrPromise.then((iconValue) => {\n          icon.value = iconValue;\n        });\n      } else {\n        icon.value = iconOrPromise;\n      }\n    }\n    if (props.iconLoader && typeof props.iconLoader === \"function\") {\n      iconHandler = createIconHandler(props.iconLoader);\n    } else if (parent && parent.props?.iconLoader) {\n      iconHandler = createIconHandler(parent.props.iconLoader);\n    } else if (props.iconLoaderUrl && typeof props.iconLoaderUrl === \"function\") {\n      iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl);\n    } else {\n      const iconPlugin = config?.plugins?.find((plugin2) => {\n        return typeof plugin2.iconHandler === \"function\";\n      });\n      if (iconPlugin) {\n        iconHandler = iconPlugin.iconHandler;\n      }\n    }\n    watch(\n      () => props.icon,\n      () => {\n        loadIcon();\n      },\n      { immediate: true }\n    );\n    return () => {\n      if (props.icon && icon.value) {\n        return h(\"span\", {\n          class: \"formkit-icon\",\n          innerHTML: icon.value\n        });\n      }\n      return null;\n    };\n  }\n});\n\nexport { FormKit_default as FormKit, FormKitIcon, FormKitKitchenSink, FormKitLazyProvider, FormKitMessages, FormKitProvider, FormKitRoot, FormKitSchema, FormKitSummary, bindings_default as bindings, componentSymbol, configSymbol, createInput, defaultConfig, defineFormKitConfig, getCurrentSchemaNode, onSSRComplete, optionsSymbol, parentSymbol, plugin, rootSymbol, ssrComplete, useConfig, useInput };\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map",
      "start": 1709718915816,
      "end": 1709718915854,
      "sourcemaps": null
    },
    {
      "name": "unplugin-formkit",
      "result": "import { defineComponent, getCurrentInstance, markRaw, watch, watchEffect, reactive, onMounted, onUnmounted, ref, provide, h, inject, computed, toRef, onBeforeUnmount, KeepAlive, Suspense, nextTick, triggerRef, isRef, isReactive, createTextVNode, resolveComponent } from 'vue';\nimport { createConfig, createNode, error, createMessage, getNode, clearErrors, setErrors, submitForm, reset, createClasses, generateClassList, warn, watchRegistry, isNode, sugar, isDOM, isComponent, isConditional, compile } from '@formkit/core';\nexport { clearErrors, errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';\nimport { cloneAny, extend, undefine, camel, kebab, nodeProps, only, except, oncePerTick, slugify, shallowClone, eq, token, isObject, empty, has, isPojo } from '@formkit/utils';\nimport { createObserver } from '@formkit/observer';\nimport * as defaultRules from '@formkit/rules';\nimport { createValidationPlugin } from '@formkit/validation';\nimport { createI18nPlugin, en } from '@formkit/i18n';\nexport { changeLocale } from '@formkit/i18n';\nimport { createSection, useSchema, localize, createLibraryPlugin, inputs, runtimeProps } from '@formkit/inputs';\nimport { createIconHandler, createThemePlugin } from '@formkit/themes';\nimport { register } from '@formkit/dev';\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar vueBindings, bindings_default;\nvar init_bindings = __esm({\n  \"packages/vue/src/bindings.ts\"() {\n    vueBindings = function vueBindings2(node) {\n      node.ledger.count(\"blocking\", (m) => m.blocking);\n      const isValid = ref(!node.ledger.value(\"blocking\"));\n      node.ledger.count(\"errors\", (m) => m.type === \"error\");\n      const hasErrors = ref(!!node.ledger.value(\"errors\"));\n      let hasTicked = false;\n      nextTick(() => {\n        hasTicked = true;\n      });\n      const availableMessages = reactive(\n        node.store.reduce((store, message3) => {\n          if (message3.visible) {\n            store[message3.key] = message3;\n          }\n          return store;\n        }, {})\n      );\n      const validationVisibility = ref(\n        node.props.validationVisibility || (node.props.type === \"checkbox\" ? \"dirty\" : \"blur\")\n      );\n      node.on(\"prop:validationVisibility\", ({ payload }) => {\n        validationVisibility.value = payload;\n      });\n      const hasShownErrors = ref(validationVisibility.value === \"live\");\n      const isRequired = ref(false);\n      const checkForRequired = (parsedRules) => {\n        isRequired.value = (parsedRules ?? []).some(\n          (rule) => rule.name === \"required\"\n        );\n      };\n      checkForRequired(node.props.parsedRules);\n      node.on(\"prop:parsedRules\", ({ payload }) => checkForRequired(payload));\n      const items = ref(node.children.map((child) => child.uid));\n      const validationVisible = computed(() => {\n        if (!context.state)\n          return false;\n        if (context.state.submitted)\n          return true;\n        if (!hasShownErrors.value && !context.state.settled) {\n          return false;\n        }\n        switch (validationVisibility.value) {\n          case \"live\":\n            return true;\n          case \"blur\":\n            return context.state.blurred;\n          case \"dirty\":\n            return context.state.dirty;\n          default:\n            return false;\n        }\n      });\n      const isComplete = computed(() => {\n        return context && hasValidation.value ? isValid.value && !hasErrors.value : context.state.dirty && !empty(context.value);\n      });\n      const hasValidation = ref(\n        Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0\n      );\n      node.on(\"prop:parsedRules\", ({ payload: rules }) => {\n        hasValidation.value = Array.isArray(rules) && rules.length > 0;\n      });\n      const messages3 = computed(() => {\n        const visibleMessages = {};\n        for (const key in availableMessages) {\n          const message3 = availableMessages[key];\n          if (message3.type !== \"validation\" || validationVisible.value) {\n            visibleMessages[key] = message3;\n          }\n        }\n        return visibleMessages;\n      });\n      const ui = reactive(\n        node.store.reduce((messages4, message3) => {\n          if (message3.type === \"ui\" && message3.visible)\n            messages4[message3.key] = message3;\n          return messages4;\n        }, {})\n      );\n      const cachedClasses = reactive({});\n      const classes2 = new Proxy(cachedClasses, {\n        get(...args) {\n          const [target, property] = args;\n          let className = Reflect.get(...args);\n          if (!className && typeof property === \"string\") {\n            if (!has(target, property) && !property.startsWith(\"__v\")) {\n              const observedNode = createObserver(node);\n              observedNode.watch((node2) => {\n                const rootClasses = typeof node2.config.rootClasses === \"function\" ? node2.config.rootClasses(property, node2) : {};\n                const globalConfigClasses = node2.config.classes ? createClasses(property, node2, node2.config.classes[property]) : {};\n                const classesPropClasses = createClasses(\n                  property,\n                  node2,\n                  node2.props[`_${property}Class`]\n                );\n                const sectionPropClasses = createClasses(\n                  property,\n                  node2,\n                  node2.props[`${property}Class`]\n                );\n                className = generateClassList(\n                  node2,\n                  property,\n                  rootClasses,\n                  globalConfigClasses,\n                  classesPropClasses,\n                  sectionPropClasses\n                );\n                target[property] = className ?? \"\";\n              });\n            }\n          }\n          return className;\n        }\n      });\n      node.on(\"prop:rootClasses\", () => {\n        const keys = Object.keys(cachedClasses);\n        for (const key of keys) {\n          delete cachedClasses[key];\n        }\n      });\n      const describedBy = computed(() => {\n        const describers = [];\n        if (context.help) {\n          describers.push(`help-${node.props.id}`);\n        }\n        for (const key in messages3.value) {\n          describers.push(`${node.props.id}-${key}`);\n        }\n        return describers.length ? describers.join(\" \") : void 0;\n      });\n      const value = ref(node.value);\n      const _value = ref(node.value);\n      const context = reactive({\n        _value,\n        attrs: node.props.attrs,\n        disabled: node.props.disabled,\n        describedBy,\n        fns: {\n          length: (obj) => Object.keys(obj).length,\n          number: (value2) => Number(value2),\n          string: (value2) => String(value2),\n          json: (value2) => JSON.stringify(value2),\n          eq: eq\n        },\n        handlers: {\n          blur: (e) => {\n            if (!node)\n              return;\n            node.store.set(\n              createMessage({ key: \"blurred\", visible: false, value: true })\n            );\n            if (typeof node.props.attrs.onBlur === \"function\") {\n              node.props.attrs.onBlur(e);\n            }\n          },\n          touch: () => {\n            const doCompare = context.dirtyBehavior === \"compare\";\n            if (node.store.dirty?.value && !doCompare)\n              return;\n            const isDirty = !eq(node.props._init, node._value);\n            if (!isDirty && !doCompare)\n              return;\n            node.store.set(\n              createMessage({ key: \"dirty\", visible: false, value: isDirty })\n            );\n          },\n          DOMInput: (e) => {\n            node.input(e.target.value);\n            node.emit(\"dom-input-event\", e);\n          }\n        },\n        help: node.props.help,\n        id: node.props.id,\n        items,\n        label: node.props.label,\n        messages: messages3,\n        didMount: false,\n        node: markRaw(node),\n        options: node.props.options,\n        defaultMessagePlacement: true,\n        slots: node.props.__slots,\n        state: {\n          blurred: false,\n          complete: isComplete,\n          dirty: false,\n          empty: empty(value),\n          submitted: false,\n          settled: node.isSettled,\n          valid: isValid,\n          errors: hasErrors,\n          rules: hasValidation,\n          validationVisible,\n          required: isRequired\n        },\n        type: node.props.type,\n        family: node.props.family,\n        ui,\n        value,\n        classes: classes2\n      });\n      node.on(\"created\", () => {\n        if (!eq(context.value, node.value)) {\n          _value.value = node.value;\n          value.value = node.value;\n          triggerRef(value);\n          triggerRef(_value);\n        }\n        (async () => {\n          await node.settled;\n          if (node)\n            node.props._init = cloneAny(node.value);\n        })();\n      });\n      node.on(\"mounted\", () => {\n        context.didMount = true;\n      });\n      node.on(\"settled\", ({ payload: isSettled }) => {\n        context.state.settled = isSettled;\n      });\n      function observeProps(observe) {\n        const propNames = Array.isArray(observe) ? observe : Object.keys(observe);\n        propNames.forEach((prop) => {\n          prop = camel(prop);\n          if (!has(context, prop)) {\n            context[prop] = node.props[prop];\n          }\n          node.on(`prop:${prop}`, ({ payload }) => {\n            context[prop] = payload;\n          });\n        });\n      }\n      const rootProps = () => {\n        const props = [\n          \"__root\",\n          \"help\",\n          \"label\",\n          \"disabled\",\n          \"options\",\n          \"type\",\n          \"attrs\",\n          \"preserve\",\n          \"preserveErrors\",\n          \"id\",\n          \"dirtyBehavior\"\n        ];\n        const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/;\n        const matchingProps = Object.keys(node.props).filter((prop) => {\n          return iconPattern.test(prop);\n        });\n        return props.concat(matchingProps);\n      };\n      observeProps(rootProps());\n      function definedAs(definition3) {\n        if (definition3.props)\n          observeProps(definition3.props);\n      }\n      node.props.definition && definedAs(node.props.definition);\n      node.on(\"added-props\", ({ payload }) => observeProps(payload));\n      node.on(\"input\", ({ payload }) => {\n        if (node.type !== \"input\" && !isRef(payload) && !isReactive(payload)) {\n          _value.value = shallowClone(payload);\n        } else {\n          _value.value = payload;\n          triggerRef(_value);\n        }\n      });\n      node.on(\"commitRaw\", ({ payload }) => {\n        if (node.type !== \"input\" && !isRef(payload) && !isReactive(payload)) {\n          value.value = _value.value = shallowClone(payload);\n        } else {\n          value.value = _value.value = payload;\n          triggerRef(value);\n        }\n        node.emit(\"modelUpdated\");\n      });\n      node.on(\"commit\", ({ payload }) => {\n        if ((!context.state.dirty || context.dirtyBehavior === \"compare\") && node.isCreated && hasTicked) {\n          if (!node.store.validating?.value) {\n            context.handlers.touch();\n          } else {\n            const receipt = node.on(\"message-removed\", ({ payload: message3 }) => {\n              if (message3.key === \"validating\") {\n                context.handlers.touch();\n                node.off(receipt);\n              }\n            });\n          }\n        }\n        if (isComplete && node.type === \"input\" && hasErrors.value && !undefine(node.props.preserveErrors)) {\n          node.store.filter(\n            (message3) => !(message3.type === \"error\" && message3.meta?.autoClear === true)\n          );\n        }\n        if (node.type === \"list\" && node.sync) {\n          items.value = node.children.map((child) => child.uid);\n        }\n        context.state.empty = empty(payload);\n      });\n      const updateState = async (message3) => {\n        if (message3.type === \"ui\" && message3.visible && !message3.meta.showAsMessage) {\n          ui[message3.key] = message3;\n        } else if (message3.visible) {\n          availableMessages[message3.key] = message3;\n        } else if (message3.type === \"state\") {\n          context.state[message3.key] = !!message3.value;\n        }\n      };\n      node.on(\"message-added\", (e) => updateState(e.payload));\n      node.on(\"message-updated\", (e) => updateState(e.payload));\n      node.on(\"message-removed\", ({ payload: message3 }) => {\n        delete ui[message3.key];\n        delete availableMessages[message3.key];\n        delete context.state[message3.key];\n      });\n      node.on(\"settled:blocking\", () => {\n        isValid.value = true;\n      });\n      node.on(\"unsettled:blocking\", () => {\n        isValid.value = false;\n      });\n      node.on(\"settled:errors\", () => {\n        hasErrors.value = false;\n      });\n      node.on(\"unsettled:errors\", () => {\n        hasErrors.value = true;\n      });\n      watch(validationVisible, (value2) => {\n        if (value2) {\n          hasShownErrors.value = true;\n        }\n      });\n      node.context = context;\n      node.emit(\"context\", node, false);\n      node.on(\"destroyed\", () => {\n        node.context = void 0;\n        node = null;\n      });\n    };\n    bindings_default = vueBindings;\n  }\n});\n\n// packages/vue/src/defaultConfig.ts\nvar defaultConfig_exports = {};\n__export(defaultConfig_exports, {\n  defaultConfig: () => defaultConfig\n});\nvar defaultConfig;\nvar init_defaultConfig = __esm({\n  \"packages/vue/src/defaultConfig.ts\"() {\n    init_bindings();\n    defaultConfig = (options = {}) => {\n      register();\n      const {\n        rules = {},\n        locales = {},\n        inputs: inputs$1 = {},\n        messages: messages3 = {},\n        locale = void 0,\n        theme = void 0,\n        iconLoaderUrl = void 0,\n        iconLoader = void 0,\n        icons = {},\n        ...nodeOptions\n      } = options;\n      const validation = createValidationPlugin({\n        ...defaultRules,\n        ...rules || {}\n      });\n      const i18n = createI18nPlugin(\n        extend({ en, ...locales || {} }, messages3)\n      );\n      const library = createLibraryPlugin(inputs, inputs$1);\n      const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader);\n      return extend(\n        {\n          plugins: [library, themePlugin, bindings_default, i18n, validation],\n          ...!locale ? {} : { config: { locale } }\n        },\n        nodeOptions || {},\n        true\n      );\n    };\n  }\n});\n\n// packages/vue/src/composables/onSSRComplete.ts\nvar isServer = typeof window === \"undefined\";\nvar ssrCompleteRegistry = /* @__PURE__ */ new Map();\nfunction ssrComplete(app) {\n  if (!isServer)\n    return;\n  const callbacks = ssrCompleteRegistry.get(app);\n  if (!callbacks)\n    return;\n  for (const callback of callbacks) {\n    callback();\n  }\n  callbacks.clear();\n  ssrCompleteRegistry.delete(app);\n}\nfunction onSSRComplete(app, callback) {\n  if (!isServer || !app)\n    return;\n  if (!ssrCompleteRegistry.has(app))\n    ssrCompleteRegistry.set(app, /* @__PURE__ */ new Set());\n  ssrCompleteRegistry.get(app)?.add(callback);\n}\n\n// packages/vue/src/FormKitSchema.ts\nvar isServer2 = typeof window === \"undefined\";\nvar memo = {};\nvar memoKeys = {};\nvar instanceKey;\nvar instanceScopes = /* @__PURE__ */ new WeakMap();\nvar raw = \"__raw__\";\nvar isClassProp = /[a-zA-Z0-9\\-][cC]lass$/;\nfunction getRef(token3, data) {\n  const value = ref(null);\n  if (token3 === \"get\") {\n    const nodeRefs = {};\n    value.value = get.bind(null, nodeRefs);\n    return value;\n  }\n  const path = token3.split(\".\");\n  watchEffect(() => {\n    value.value = getValue(\n      isRef(data) ? data.value : data,\n      path\n    );\n  });\n  return value;\n}\nfunction getValue(set, path) {\n  if (Array.isArray(set)) {\n    for (const subset of set) {\n      const value = subset !== false && getValue(subset, path);\n      if (value !== void 0)\n        return value;\n    }\n    return void 0;\n  }\n  let foundValue = void 0;\n  let obj = set;\n  for (const i in path) {\n    const key = path[i];\n    if (typeof obj !== \"object\" || obj === null) {\n      foundValue = void 0;\n      break;\n    }\n    const currentValue = obj[key];\n    if (Number(i) === path.length - 1 && currentValue !== void 0) {\n      foundValue = typeof currentValue === \"function\" ? currentValue.bind(obj) : currentValue;\n      break;\n    }\n    obj = currentValue;\n  }\n  return foundValue;\n}\nfunction get(nodeRefs, id) {\n  if (typeof id !== \"string\")\n    return warn(650);\n  if (!(id in nodeRefs))\n    nodeRefs[id] = ref(void 0);\n  if (nodeRefs[id].value === void 0) {\n    nodeRefs[id].value = null;\n    const root = getNode(id);\n    if (root)\n      nodeRefs[id].value = root.context;\n    watchRegistry(id, ({ payload: node }) => {\n      nodeRefs[id].value = isNode(node) ? node.context : node;\n    });\n  }\n  return nodeRefs[id].value;\n}\nfunction parseSchema(library, schema, memoKey) {\n  function parseCondition(library2, node) {\n    const condition = provider(compile(node.if), { if: true });\n    const children = createElements(library2, node.then);\n    const alternate = node.else ? createElements(library2, node.else) : null;\n    return [condition, children, alternate];\n  }\n  function parseConditionAttr(attr, _default) {\n    const condition = provider(compile(attr.if));\n    let b = () => _default;\n    let a = () => _default;\n    if (typeof attr.then === \"object\") {\n      a = parseAttrs(attr.then, void 0);\n    } else if (typeof attr.then === \"string\" && attr.then?.startsWith(\"$\")) {\n      a = provider(compile(attr.then));\n    } else {\n      a = () => attr.then;\n    }\n    if (has(attr, \"else\")) {\n      if (typeof attr.else === \"object\") {\n        b = parseAttrs(attr.else);\n      } else if (typeof attr.else === \"string\" && attr.else?.startsWith(\"$\")) {\n        b = provider(compile(attr.else));\n      } else {\n        b = () => attr.else;\n      }\n    }\n    return () => condition() ? a() : b();\n  }\n  function parseAttrs(unparsedAttrs, bindExp, _default = {}) {\n    const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));\n    const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});\n    const setters = [\n      (attrs) => {\n        const bound = boundAttrs();\n        for (const attr in bound) {\n          if (!explicitAttrs.has(attr)) {\n            attrs[attr] = bound[attr];\n          }\n        }\n      }\n    ];\n    if (unparsedAttrs) {\n      if (isConditional(unparsedAttrs)) {\n        const condition = parseConditionAttr(\n          unparsedAttrs,\n          _default\n        );\n        return condition;\n      }\n      for (let attr in unparsedAttrs) {\n        const value = unparsedAttrs[attr];\n        let getValue2;\n        const isStr = typeof value === \"string\";\n        if (attr.startsWith(raw)) {\n          attr = attr.substring(7);\n          getValue2 = () => value;\n        } else if (isStr && value.startsWith(\"$\") && value.length > 1 && !(value.startsWith(\"$reset\") && isClassProp.test(attr))) {\n          getValue2 = provider(compile(value));\n        } else if (typeof value === \"object\" && isConditional(value)) {\n          getValue2 = parseConditionAttr(value, void 0);\n        } else if (typeof value === \"object\" && isPojo(value)) {\n          getValue2 = parseAttrs(value);\n        } else {\n          getValue2 = () => value;\n        }\n        setters.push((attrs) => {\n          attrs[attr] = getValue2();\n        });\n      }\n    }\n    return () => {\n      const attrs = Array.isArray(unparsedAttrs) ? [] : {};\n      setters.forEach((setter) => setter(attrs));\n      return attrs;\n    };\n  }\n  function parseNode(library2, _node) {\n    let element = null;\n    let attrs = () => null;\n    let condition = false;\n    let children = null;\n    let alternate = null;\n    let iterator = null;\n    let resolve = false;\n    const node = sugar(_node);\n    if (isDOM(node)) {\n      element = node.$el;\n      attrs = node.$el !== \"text\" ? parseAttrs(node.attrs, node.bind) : () => null;\n    } else if (isComponent(node)) {\n      if (typeof node.$cmp === \"string\") {\n        if (has(library2, node.$cmp)) {\n          element = library2[node.$cmp];\n        } else {\n          element = node.$cmp;\n          resolve = true;\n        }\n      } else {\n        element = node.$cmp;\n      }\n      attrs = parseAttrs(node.props, node.bind);\n    } else if (isConditional(node)) {\n      [condition, children, alternate] = parseCondition(library2, node);\n    }\n    if (!isConditional(node) && \"if\" in node) {\n      condition = provider(compile(node.if));\n    } else if (!isConditional(node) && element === null) {\n      condition = () => true;\n    }\n    if (\"children\" in node && node.children) {\n      if (typeof node.children === \"string\") {\n        if (node.children.startsWith(\"$slots.\")) {\n          element = element === \"text\" ? \"slot\" : element;\n          children = provider(compile(node.children));\n        } else if (node.children.startsWith(\"$\") && node.children.length > 1) {\n          const value = provider(compile(node.children));\n          children = () => String(value());\n        } else {\n          children = () => String(node.children);\n        }\n      } else if (Array.isArray(node.children)) {\n        children = createElements(library2, node.children);\n      } else {\n        const [childCondition, c, a] = parseCondition(library2, node.children);\n        children = (iterationData) => childCondition && childCondition() ? c && c(iterationData) : a && a(iterationData);\n      }\n    }\n    if (isComponent(node)) {\n      if (children) {\n        const produceChildren = children;\n        children = (iterationData) => {\n          return {\n            default(slotData2, key) {\n              const currentKey = instanceKey;\n              if (key)\n                instanceKey = key;\n              if (slotData2)\n                instanceScopes.get(instanceKey)?.unshift(slotData2);\n              if (iterationData)\n                instanceScopes.get(instanceKey)?.unshift(iterationData);\n              const c = produceChildren(iterationData);\n              if (slotData2)\n                instanceScopes.get(instanceKey)?.shift();\n              if (iterationData)\n                instanceScopes.get(instanceKey)?.shift();\n              instanceKey = currentKey;\n              return c;\n            }\n          };\n        };\n        children.slot = true;\n      } else {\n        children = () => ({});\n      }\n    }\n    if (\"for\" in node && node.for) {\n      const values = node.for.length === 3 ? node.for[2] : node.for[1];\n      const getValues = typeof values === \"string\" && values.startsWith(\"$\") ? provider(compile(values)) : () => values;\n      iterator = [\n        getValues,\n        node.for[0],\n        node.for.length === 3 ? String(node.for[1]) : null\n      ];\n    }\n    return [condition, element, attrs, children, alternate, iterator, resolve];\n  }\n  function createSlots(children, iterationData) {\n    const slots = children(iterationData);\n    const currentKey = instanceKey;\n    return Object.keys(slots).reduce((allSlots, slotName) => {\n      const slotFn = slots && slots[slotName];\n      allSlots[slotName] = (data) => {\n        return slotFn && slotFn(data, currentKey) || null;\n      };\n      return allSlots;\n    }, {});\n  }\n  function createElement(library2, node) {\n    const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library2, node);\n    let createNodes = (iterationData) => {\n      if (condition && element === null && children) {\n        return condition() ? children(iterationData) : alternate && alternate(iterationData);\n      }\n      if (element && (!condition || condition())) {\n        if (element === \"text\" && children) {\n          return createTextVNode(String(children()));\n        }\n        if (element === \"slot\" && children)\n          return children(iterationData);\n        const el = resolve ? resolveComponent(element) : element;\n        const slots = children?.slot ? createSlots(children, iterationData) : null;\n        return h(\n          el,\n          attrs(),\n          slots || (children ? children(iterationData) : [])\n        );\n      }\n      return typeof alternate === \"function\" ? alternate(iterationData) : alternate;\n    };\n    if (iterator) {\n      const repeatedNode = createNodes;\n      const [getValues, valueName, keyName] = iterator;\n      createNodes = () => {\n        const _v = getValues();\n        const values = Number.isFinite(_v) ? Array(Number(_v)).fill(0).map((_, i) => i) : _v;\n        const fragment = [];\n        if (typeof values !== \"object\")\n          return null;\n        const instanceScope = instanceScopes.get(instanceKey) || [];\n        const isArray = Array.isArray(values);\n        for (const key in values) {\n          if (isArray && key in Array.prototype)\n            continue;\n          const iterationData = Object.defineProperty(\n            {\n              ...instanceScope.reduce(\n                (previousIterationData, scopedData) => {\n                  if (previousIterationData.__idata) {\n                    return { ...previousIterationData, ...scopedData };\n                  }\n                  return scopedData;\n                },\n                {}\n              ),\n              [valueName]: values[key],\n              ...keyName !== null ? { [keyName]: isArray ? Number(key) : key } : {}\n            },\n            \"__idata\",\n            { enumerable: false, value: true }\n          );\n          instanceScope.unshift(iterationData);\n          fragment.push(repeatedNode.bind(null, iterationData)());\n          instanceScope.shift();\n        }\n        return fragment;\n      };\n    }\n    return createNodes;\n  }\n  function createElements(library2, schema2) {\n    if (Array.isArray(schema2)) {\n      const els = schema2.map(createElement.bind(null, library2));\n      return (iterationData) => els.map((element2) => element2(iterationData));\n    }\n    const element = createElement(library2, schema2);\n    return (iterationData) => element(iterationData);\n  }\n  const providers = [];\n  function provider(compiled, hints = {}) {\n    const compiledFns = /* @__PURE__ */ new WeakMap();\n    providers.push((callback, key) => {\n      compiledFns.set(\n        key,\n        compiled.provide((tokens) => callback(tokens, hints))\n      );\n    });\n    return () => compiledFns.get(instanceKey)();\n  }\n  function createInstance(providerCallback, key) {\n    memoKey ?? (memoKey = toMemoKey(schema));\n    const [render, compiledProviders] = has(memo, memoKey) ? memo[memoKey] : [createElements(library, schema), providers];\n    if (!isServer2) {\n      memoKeys[memoKey] ?? (memoKeys[memoKey] = 0);\n      memoKeys[memoKey]++;\n      memo[memoKey] = [render, compiledProviders];\n    }\n    compiledProviders.forEach((compiledProvider) => {\n      compiledProvider(providerCallback, key);\n    });\n    return () => {\n      instanceKey = key;\n      return render();\n    };\n  }\n  return createInstance;\n}\nfunction useScope(token3, defaultValue) {\n  const scopedData = instanceScopes.get(instanceKey) || [];\n  let scopedValue = void 0;\n  if (scopedData.length) {\n    scopedValue = getValue(scopedData, token3.split(\".\"));\n  }\n  return scopedValue === void 0 ? defaultValue : scopedValue;\n}\nfunction slotData(data, key) {\n  return new Proxy(data, {\n    get(...args) {\n      let data2 = void 0;\n      const property = args[1];\n      if (typeof property === \"string\") {\n        const prevKey = instanceKey;\n        instanceKey = key;\n        data2 = useScope(property, void 0);\n        instanceKey = prevKey;\n      }\n      return data2 !== void 0 ? data2 : Reflect.get(...args);\n    }\n  });\n}\nfunction createRenderFn(instanceCreator, data, instanceKey2) {\n  return instanceCreator(\n    (requirements, hints = {}) => {\n      return requirements.reduce((tokens, token3) => {\n        if (token3.startsWith(\"slots.\")) {\n          const slot = token3.substring(6);\n          const hasSlot = () => data.slots && has(data.slots, slot) && typeof data.slots[slot] === \"function\";\n          if (hints.if) {\n            tokens[token3] = hasSlot;\n          } else if (data.slots) {\n            const scopedData = slotData(data, instanceKey2);\n            tokens[token3] = () => hasSlot() ? data.slots[slot](scopedData) : null;\n          }\n        } else {\n          const value = getRef(token3, data);\n          tokens[token3] = () => useScope(token3, value.value);\n        }\n        return tokens;\n      }, {});\n    },\n    instanceKey2\n  );\n}\nfunction clean(schema, memoKey, instanceKey2) {\n  memoKey ?? (memoKey = toMemoKey(schema));\n  memoKeys[memoKey]--;\n  if (memoKeys[memoKey] === 0) {\n    delete memoKeys[memoKey];\n    const [, providers] = memo[memoKey];\n    delete memo[memoKey];\n    providers.length = 0;\n  }\n  instanceScopes.delete(instanceKey2);\n}\nfunction toMemoKey(schema) {\n  return JSON.stringify(schema, (_, value) => {\n    if (typeof value === \"function\") {\n      return value.toString();\n    }\n    return value;\n  });\n}\nvar FormKitSchema = /* @__PURE__ */ defineComponent({\n  name: \"FormKitSchema\",\n  props: {\n    schema: {\n      type: [Array, Object],\n      required: true\n    },\n    data: {\n      type: Object,\n      default: () => ({})\n    },\n    library: {\n      type: Object,\n      default: () => ({})\n    },\n    memoKey: {\n      type: String,\n      required: false\n    }\n  },\n  emits: [\"mounted\"],\n  setup(props, context) {\n    const instance = getCurrentInstance();\n    let instanceKey2 = {};\n    instanceScopes.set(instanceKey2, []);\n    const library = { FormKit: markRaw(FormKit_default), ...props.library };\n    let provider = parseSchema(library, props.schema, props.memoKey);\n    let render;\n    let data;\n    if (!isServer2) {\n      watch(\n        () => props.schema,\n        (newSchema, oldSchema) => {\n          const oldKey = instanceKey2;\n          instanceKey2 = {};\n          instanceScopes.set(instanceKey2, []);\n          provider = parseSchema(library, props.schema, props.memoKey);\n          render = createRenderFn(provider, data, instanceKey2);\n          if (newSchema === oldSchema) {\n            (instance?.proxy?.$forceUpdate)();\n          }\n          clean(props.schema, props.memoKey, oldKey);\n        },\n        { deep: true }\n      );\n    }\n    watchEffect(() => {\n      data = Object.assign(reactive(props.data ?? {}), {\n        slots: context.slots\n      });\n      context.slots;\n      render = createRenderFn(provider, data, instanceKey2);\n    });\n    function cleanUp() {\n      clean(props.schema, props.memoKey, instanceKey2);\n      if (data.node)\n        data.node.destroy();\n      data.slots = null;\n      data = null;\n      render = null;\n    }\n    onMounted(() => context.emit(\"mounted\"));\n    onUnmounted(cleanUp);\n    onSSRComplete(getCurrentInstance()?.appContext.app, cleanUp);\n    return () => render ? render() : null;\n  }\n});\nvar FormKitSchema_default = FormKitSchema;\nvar isServer3 = typeof window === \"undefined\";\nvar parentSymbol = Symbol(\"FormKitParent\");\nvar componentSymbol = Symbol(\"FormKitComponentCallback\");\nvar currentSchemaNode = null;\nvar getCurrentSchemaNode = () => currentSchemaNode;\nfunction FormKit(props, context) {\n  const node = useInput(props, context);\n  if (!node.props.definition)\n    error(600, node);\n  if (node.props.definition.component) {\n    return () => h(\n      node.props.definition?.component,\n      {\n        context: node.context\n      },\n      { ...context.slots }\n    );\n  }\n  const schema = ref([]);\n  let memoKey = node.props.definition.schemaMemoKey;\n  const generateSchema = () => {\n    const schemaDefinition = node.props?.definition?.schema;\n    if (!schemaDefinition)\n      error(601, node);\n    if (typeof schemaDefinition === \"function\") {\n      currentSchemaNode = node;\n      schema.value = schemaDefinition({ ...props.sectionsSchema || {} });\n      currentSchemaNode = null;\n      if (memoKey && props.sectionsSchema || \"memoKey\" in schemaDefinition && typeof schemaDefinition.memoKey === \"string\") {\n        memoKey = (memoKey ?? schemaDefinition?.memoKey) + JSON.stringify(props.sectionsSchema);\n      }\n    } else {\n      schema.value = schemaDefinition;\n    }\n  };\n  generateSchema();\n  if (!isServer3) {\n    node.on(\"schema\", () => {\n      memoKey += \"♻️\";\n      generateSchema();\n    });\n  }\n  context.emit(\"node\", node);\n  const definitionLibrary = node.props.definition.library;\n  const library = {\n    FormKit: markRaw(formkitComponent),\n    ...definitionLibrary\n  };\n  function didMount() {\n    node.emit(\"mounted\");\n  }\n  context.expose({ node });\n  return () => h(\n    FormKitSchema,\n    {\n      schema: schema.value,\n      data: node.context,\n      onMounted: didMount,\n      library,\n      memoKey\n    },\n    { ...context.slots }\n  );\n}\nvar formkitComponent = /* @__PURE__ */ defineComponent(\n  FormKit,\n  {\n    props: runtimeProps,\n    inheritAttrs: false\n  }\n);\nvar FormKit_default = formkitComponent;\nvar rootSymbol = Symbol();\nvar FormKitRoot = /* @__PURE__ */ defineComponent((_p, context) => {\n  const boundary = ref(null);\n  const showBody = ref(false);\n  const shadowRoot = ref(void 0);\n  const stopWatch = watch(boundary, (el) => {\n    let parent = el;\n    let root = null;\n    while (parent = parent?.parentNode) {\n      root = parent;\n      if (root instanceof ShadowRoot || root instanceof Document) {\n        foundRoot(root);\n        break;\n      }\n    }\n    stopWatch();\n    showBody.value = true;\n  });\n  provide(rootSymbol, shadowRoot);\n  function foundRoot(root) {\n    shadowRoot.value = root;\n  }\n  return () => showBody.value && context.slots.default ? context.slots.default() : h(\"template\", { ref: boundary });\n});\nfunction createPlugin(app, options) {\n  app.component(options.alias || \"FormKit\", FormKit_default).component(options.schemaAlias || \"FormKitSchema\", FormKitSchema_default);\n  return {\n    get: getNode,\n    setLocale: (locale) => {\n      if (options.config?.rootConfig) {\n        options.config.rootConfig.locale = locale;\n      }\n    },\n    clearErrors,\n    setErrors,\n    submit: submitForm,\n    reset\n  };\n}\nvar optionsSymbol = Symbol.for(\"FormKitOptions\");\nvar configSymbol = Symbol.for(\"FormKitConfig\");\nvar plugin = {\n  install(app, _options) {\n    const options = Object.assign(\n      {\n        alias: \"FormKit\",\n        schemaAlias: \"FormKitSchema\"\n      },\n      typeof _options === \"function\" ? _options() : _options\n    );\n    const rootConfig = createConfig(options.config || {});\n    options.config = { rootConfig };\n    app.config.globalProperties.$formkit = createPlugin(app, options);\n    app.provide(optionsSymbol, options);\n    app.provide(configSymbol, rootConfig);\n    if (typeof window !== \"undefined\") {\n      globalThis.__FORMKIT_CONFIGS__ = (globalThis.__FORMKIT_CONFIGS__ || []).concat([rootConfig]);\n    }\n  }\n};\n\n// packages/vue/src/composables/useInput.ts\nvar isBrowser = typeof window !== \"undefined\";\nvar pseudoProps = [\n  // Boolean props\n  \"ignore\",\n  \"disabled\",\n  \"preserve\",\n  // String props\n  \"help\",\n  \"label\",\n  /^preserve(-e|E)rrors/,\n  /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/,\n  /^[a-zA-Z-]+(?:-class|Class)$/,\n  \"prefixIcon\",\n  \"suffixIcon\",\n  /^[a-zA-Z-]+(?:-icon|Icon)$/\n];\nvar boolProps = [\"disabled\", \"ignore\", \"preserve\"];\nfunction classesToNodeProps(node, props) {\n  if (props.classes) {\n    Object.keys(props.classes).forEach(\n      (key) => {\n        if (typeof key === \"string\") {\n          node.props[`_${key}Class`] = props.classes[key];\n          if (isObject(props.classes[key]) && key === \"inner\")\n            Object.values(props.classes[key]);\n        }\n      }\n    );\n  }\n}\nfunction onlyListeners(props) {\n  if (!props)\n    return {};\n  const knownListeners = [\"Submit\", \"SubmitRaw\", \"SubmitInvalid\"].reduce(\n    (listeners, listener) => {\n      const name = `on${listener}`;\n      if (name in props) {\n        if (typeof props[name] === \"function\") {\n          listeners[name] = props[name];\n        }\n      }\n      return listeners;\n    },\n    {}\n  );\n  return knownListeners;\n}\nfunction useInput(props, context, options = {}) {\n  const config = Object.assign({}, inject(optionsSymbol) || {}, options);\n  const __root = inject(rootSymbol, ref(isBrowser ? document : void 0));\n  const __cmpCallback = inject(componentSymbol, () => {\n  });\n  const instance = getCurrentInstance();\n  const listeners = onlyListeners(instance?.vnode.props);\n  const isVModeled = [\"modelValue\", \"model-value\"].some(\n    (prop) => prop in (instance?.vnode.props ?? {})\n  );\n  let isMounted = false;\n  onMounted(() => {\n    isMounted = true;\n  });\n  const value = props.modelValue !== void 0 ? props.modelValue : cloneAny(context.attrs.value);\n  function createInitialProps() {\n    const initialProps2 = {\n      ...nodeProps(props),\n      ...listeners,\n      type: props.type ?? \"text\",\n      __root: __root.value,\n      __slots: context.slots\n    };\n    const attrs = except(nodeProps(context.attrs), pseudoProps);\n    if (!attrs.key)\n      attrs.key = token();\n    initialProps2.attrs = attrs;\n    const propValues = only(nodeProps(context.attrs), pseudoProps);\n    for (const propName in propValues) {\n      if (boolProps.includes(propName) && propValues[propName] === \"\") {\n        propValues[propName] = true;\n      }\n      initialProps2[camel(propName)] = propValues[propName];\n    }\n    const classesProps = { props: {} };\n    classesToNodeProps(classesProps, props);\n    Object.assign(initialProps2, classesProps.props);\n    if (typeof initialProps2.type !== \"string\") {\n      initialProps2.definition = initialProps2.type;\n      delete initialProps2.type;\n    }\n    return initialProps2;\n  }\n  const initialProps = createInitialProps();\n  const parent = initialProps.ignore ? null : props.parent || inject(parentSymbol, null);\n  const node = createNode(\n    extend(\n      config || {},\n      {\n        name: props.name || void 0,\n        value,\n        parent,\n        plugins: (config.plugins || []).concat(props.plugins ?? []),\n        config: props.config || {},\n        props: initialProps,\n        index: props.index,\n        sync: !!undefine(context.attrs.sync || context.attrs.dynamic)\n      },\n      false,\n      true\n    )\n  );\n  __cmpCallback(node);\n  if (!node.props.definition)\n    error(600, node);\n  const lateBoundProps = ref(\n    new Set(\n      Array.isArray(node.props.__propDefs) ? node.props.__propDefs : Object.keys(node.props.__propDefs ?? {})\n    )\n  );\n  node.on(\n    \"added-props\",\n    ({ payload: lateProps }) => {\n      const propNames = Array.isArray(lateProps) ? lateProps : Object.keys(lateProps ?? {});\n      propNames.forEach((newProp) => lateBoundProps.value.add(newProp));\n    }\n  );\n  const pseudoPropNames = computed(\n    () => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\n      if (typeof prop === \"string\") {\n        names.push(camel(prop));\n        names.push(kebab(prop));\n      } else {\n        names.push(prop);\n      }\n      return names;\n    }, [])\n  );\n  watchEffect(() => classesToNodeProps(node, props));\n  const passThrough = nodeProps(props);\n  for (const prop in passThrough) {\n    watch(\n      () => props[prop],\n      () => {\n        if (props[prop] !== void 0) {\n          node.props[prop] = props[prop];\n        }\n      }\n    );\n  }\n  watchEffect(() => {\n    node.props.__root = __root.value;\n  });\n  const attributeWatchers = /* @__PURE__ */ new Set();\n  const possibleProps = nodeProps(context.attrs);\n  watchEffect(() => {\n    watchAttributes(only(possibleProps, pseudoPropNames.value));\n  });\n  function watchAttributes(attrProps) {\n    attributeWatchers.forEach((stop) => {\n      stop();\n      attributeWatchers.delete(stop);\n    });\n    for (const prop in attrProps) {\n      const camelName = camel(prop);\n      attributeWatchers.add(\n        watch(\n          () => context.attrs[prop],\n          () => {\n            node.props[camelName] = context.attrs[prop];\n          }\n        )\n      );\n    }\n  }\n  watchEffect(() => {\n    const attrs = except(nodeProps(context.attrs), pseudoPropNames.value);\n    if (\"multiple\" in attrs)\n      attrs.multiple = undefine(attrs.multiple);\n    if (typeof attrs.onBlur === \"function\") {\n      attrs.onBlur = oncePerTick(attrs.onBlur);\n    }\n    node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);\n  });\n  watchEffect(() => {\n    const messages3 = (props.errors ?? []).map(\n      (error3) => createMessage({\n        key: slugify(error3),\n        type: \"error\",\n        value: error3,\n        meta: { source: \"prop\" }\n      })\n    );\n    node.store.apply(\n      messages3,\n      (message3) => message3.type === \"error\" && message3.meta.source === \"prop\"\n    );\n  });\n  if (node.type !== \"input\") {\n    const sourceKey = `${node.name}-prop`;\n    watchEffect(() => {\n      const inputErrors = props.inputErrors ?? {};\n      const keys = Object.keys(inputErrors);\n      if (!keys.length)\n        node.clearErrors(true, sourceKey);\n      const messages3 = keys.reduce((messages4, key) => {\n        let value2 = inputErrors[key];\n        if (typeof value2 === \"string\")\n          value2 = [value2];\n        if (Array.isArray(value2)) {\n          messages4[key] = value2.map(\n            (error3) => createMessage({\n              key: error3,\n              type: \"error\",\n              value: error3,\n              meta: { source: sourceKey }\n            })\n          );\n        }\n        return messages4;\n      }, {});\n      node.store.apply(\n        messages3,\n        (message3) => message3.type === \"error\" && message3.meta.source === sourceKey\n      );\n    });\n  }\n  watchEffect(() => Object.assign(node.config, props.config));\n  if (node.type !== \"input\") {\n    provide(parentSymbol, node);\n  }\n  let clonedValueBeforeVmodel = void 0;\n  node.on(\"modelUpdated\", () => {\n    context.emit(\"inputRaw\", node.context?.value, node);\n    if (isMounted) {\n      context.emit(\"input\", node.context?.value, node);\n    }\n    if (isVModeled && node.context) {\n      clonedValueBeforeVmodel = cloneAny(node.value);\n      context.emit(\"update:modelValue\", shallowClone(node.value));\n    }\n  });\n  if (isVModeled) {\n    watch(\n      toRef(props, \"modelValue\"),\n      (value2) => {\n        if (!eq(clonedValueBeforeVmodel, value2)) {\n          node.input(value2, false);\n        }\n      },\n      { deep: true }\n    );\n    if (node.value !== value) {\n      node.emit(\"modelUpdated\");\n    }\n  }\n  onBeforeUnmount(() => node.destroy());\n  return node;\n}\nvar totalCreated = 1;\nfunction isComponent2(obj) {\n  return typeof obj === \"function\" && obj.length === 2 || typeof obj === \"object\" && !Array.isArray(obj) && !(\"$el\" in obj) && !(\"$cmp\" in obj) && !(\"if\" in obj);\n}\nfunction createInput(schemaOrComponent, definitionOptions = {}, sectionsSchema = {}) {\n  const definition3 = {\n    type: \"input\",\n    ...definitionOptions\n  };\n  let schema;\n  if (isComponent2(schemaOrComponent)) {\n    const cmpName = `SchemaComponent${totalCreated++}`;\n    schema = createSection(\"input\", () => ({\n      $cmp: cmpName,\n      props: {\n        context: \"$node.context\"\n      }\n    }));\n    definition3.library = { [cmpName]: markRaw(schemaOrComponent) };\n  } else if (typeof schemaOrComponent === \"function\") {\n    schema = schemaOrComponent;\n  } else {\n    schema = createSection(\"input\", () => cloneAny(schemaOrComponent));\n  }\n  definition3.schema = useSchema(schema || \"Schema undefined\", sectionsSchema);\n  if (!definition3.schemaMemoKey) {\n    definition3.schemaMemoKey = `${Math.random()}`;\n  }\n  return definition3;\n}\n\n// packages/vue/src/composables/defineFormKitConfig.ts\nfunction defineFormKitConfig(config) {\n  return () => typeof config === \"function\" ? config() : config;\n}\nvar inputList = {};\nvar schemas = {};\nvar classes = {\n  container: `\n    formkit-kitchen-sink \n    p-8\n  `,\n  tabs: `\n    formkit-tabs \n    mt-4 \n    mr-[min(350px,25vw)]\n  `,\n  tab: `\n    formkit-kitchen-sink-tab\n    inline-block\n    mb-4\n    -mr-px\n    cursor-pointer\n    px-4\n    py-2\n    border\n    border-neutral-200\n    text-neutral-800\n    data-[active]:bg-neutral-800\n    data-[active]:border-neutral-800\n    data-[active]:text-neutral-50\n    hover:bg-neutral-100\n    hover:text-neutral-900\n    dark:border-neutral-700\n    dark:text-neutral-50\n    dark:data-[active]:bg-neutral-100\n    dark:data-[active]:border-neutral-100\n    dark:data-[active]:text-neutral-800\n    dark:hover:bg-neutral-800\n    dark:hover:text-neutral-50\n  `,\n  filterContainer: `\n    formkit-filter-container\n    grid\n    grid-cols-[repeat(auto-fit,300px)]\n    mr-[min(350px,25vw)]\n    -mt-4\n    mb-8\n    px-4\n    pt-8\n    pb-4\n    border\n    relative\n    -translate-y-px\n    max-w-[1000px]\n    border-neutral-200\n    dark:border-neutral-700\n  `,\n  filterGroup: `\n    formkit-filter-group\n    mr-8\n    mb-8\n    [&_legend]:text-lg\n    [&_ul]:columns-2\n    [&_ul>li:first-child]:[column-span:all]\n    [&_ul>li:first-child]:mt-2\n    [&_ul>li:first-child]:mb-2\n    [&_ul>li:first-child]:pb-2\n    [&_ul>li:first-child]:border-b\n    [&_ul>li:first-child]:border-neutral-200\n    dark:[&_ul>li:first-child]:border-neutral-700\n  `,\n  formContainer: `\n    formkit-form-container\n    w-full\n    bg-white\n    rounded\n    border\n    border-neutral-100\n    shadow-lg\n    max-w-[800px]\n    p-[min(5vw,5rem)]\n    dark:bg-neutral-900\n    dark:border-neutral-800\n    dark:shadow-3xl\n    [&_form>h1]:text-2xl\n    [&_form>h1]:mb-4\n    [&_form>h1]:font-bold\n    [&_form>h1+p]:text-base\n    [&_form>h1+p]:mb-4\n    [&_form>h1+p]:-mt-2\n    [&_form_.double]:flex\n    [&_form_.double>*]:w-1/2\n    [&_form_.double>*:first-child]:mr-2\n    [&_form_.triple]:flex\n    [&_form_.triple>*]:w-1/3\n    [&_form_.triple>*:first-child]:mr-2\n    [&_form_.triple>*:last-child]:ml-2\n  `,\n  inputs: `formkit-inputs`,\n  specimen: `\n    formkit-specimen \n    flex \n    flex-col \n    p-2 \n    max-w-[75vw]\n  `,\n  inputSection: `\n    group/section\n    formkit-input-section \n    mr-[min(325px,25vw)]\n  `,\n  specimenGroup: `\n    formkit-specimen-group\n    grid\n    mb-16\n    grid-cols-[repeat(auto-fit,400px)]\n    group-data-[type=\"transferlist\"]/section:grid-cols-[repeat(auto-fit,650px)]\n    group-data-[type=\"multi-step\"]/section:grid-cols-[repeat(auto-fit,550px)]\n  `,\n  inputType: `\n    formkit-input-type\n    block\n    font-bold\n    text-neutral-900\n    border-b\n    border-neutral-100\n    text-3xl\n    mb-8\n    pb-2\n    capitalize\n    dark:border-neutral-800 \n    dark:text-neutral-50\n  `\n};\nasync function fetchInputList() {\n  const response = await fetch(\n    \"https://raw.githubusercontent.com/formkit/input-schemas/master/index.json\"\n  );\n  const json = await response.json();\n  return json;\n}\nasync function fetchInputSchema(input) {\n  try {\n    const response = await fetch(\n      `https://raw.githubusercontent.com/formkit/input-schemas/master/schemas/${input}.json`\n    );\n    const json = await response.json();\n    return json;\n  } catch (error3) {\n    console.error(error3);\n  }\n}\nvar FormKitKitchenSink = /* @__PURE__ */ defineComponent({\n  name: \"FormKitKitchenSink\",\n  props: {\n    schemas: {\n      type: Array,\n      required: false\n    },\n    pro: {\n      type: Boolean,\n      default: true\n    },\n    addons: {\n      type: Boolean,\n      default: true\n    },\n    forms: {\n      type: Boolean,\n      default: true\n    },\n    navigation: {\n      type: Boolean,\n      default: true\n    }\n  },\n  async setup(props) {\n    onMounted(() => {\n      const filterNode = getNode(\"filter-checkboxes\");\n      data.filters = computed(() => {\n        if (!filterNode?.context)\n          return [];\n        const filters = filterNode.context.value;\n        const filterValues = [];\n        Object.keys(filters).forEach((key) => {\n          filterValues.push(...filters[key]);\n        });\n        return filterValues;\n      });\n    });\n    inputList = Object.keys(inputList).length ? inputList : await fetchInputList();\n    const promises = [];\n    const activeTab = ref(\"\");\n    const inputCheckboxes = computed(() => {\n      const inputGroups = {\n        core: { label: \"Inputs\", name: \"core\", inputs: inputList.core }\n      };\n      if (props.pro) {\n        inputGroups.pro = {\n          label: \"Pro Inputs\",\n          name: \"pro\",\n          inputs: inputList.pro\n        };\n      }\n      if (props.addons) {\n        inputGroups.addons = {\n          label: \"Add-ons\",\n          name: \"addons\",\n          inputs: inputList.addons\n        };\n      }\n      return inputGroups;\n    });\n    if (!props.schemas) {\n      const coreInputPromises = inputList.core.map(async (schema) => {\n        const response = await fetchInputSchema(schema);\n        schemas[schema] = response;\n      });\n      promises.push(...coreInputPromises);\n      if (props.forms) {\n        const formsPromises = inputList.forms.map(async (schema) => {\n          const schemaName = `form/${schema}`;\n          const response = await fetchInputSchema(schemaName);\n          schemas[schemaName] = response;\n        });\n        promises.push(...formsPromises);\n      }\n      if (props.pro) {\n        const proInputPromises = inputList.pro.map(async (schema) => {\n          const response = await fetchInputSchema(schema);\n          schemas[schema] = response;\n        });\n        promises.push(...proInputPromises);\n      }\n      if (props.addons) {\n        const addonPromises = inputList.addons.map(async (schema) => {\n          const response = await fetchInputSchema(schema);\n          schemas[schema] = response;\n        });\n        promises.push(...addonPromises);\n      }\n    } else {\n      const schemaPromises = props.schemas.map(async (schema) => {\n        const response = await fetchInputSchema(`${schema}`);\n        schemas[`${schema}`] = response;\n      });\n      promises.push(...schemaPromises);\n    }\n    const selectAll = (node) => {\n      let previousValue = [];\n      let skip = false;\n      if (node.props.type !== \"checkbox\")\n        return;\n      node.on(\"created\", () => {\n        const currentValue = node.value;\n        if (Array.isArray(currentValue) && currentValue.length === 1 && currentValue[0] === \"all\") {\n          node.input(\n            node.props.options.map((option) => {\n              if (typeof option !== \"string\")\n                return option.value;\n              return option;\n            })\n          );\n        }\n        previousValue = Array.isArray(node.value) ? node.value : [];\n      });\n      node.on(\"commit\", ({ payload }) => {\n        if (skip) {\n          skip = false;\n          return;\n        }\n        if (!Array.isArray(payload))\n          return;\n        const previousValueHadAll = previousValue.includes(\"all\");\n        const currentValueHasAll = payload.includes(\"all\");\n        if (!previousValueHadAll && currentValueHasAll) {\n          const computedOptions = node.props.options.map(\n            (option) => {\n              if (typeof option !== \"string\")\n                return option.value;\n              return option;\n            }\n          );\n          node.input(computedOptions);\n          previousValue = computedOptions;\n          return;\n        }\n        if (previousValueHadAll && !currentValueHasAll) {\n          node.input([]);\n          previousValue = [];\n          return;\n        }\n        const valueMinusAll = payload.filter((value) => value !== \"all\");\n        if (valueMinusAll.length < node.props.options.length - 1 && currentValueHasAll) {\n          node.input(valueMinusAll);\n          previousValue = valueMinusAll;\n          skip = true;\n          return;\n        }\n        if (valueMinusAll.length === node.props.options.length - 1 && !currentValueHasAll) {\n          const computedOptions = node.props.options.map(\n            (option) => {\n              if (typeof option !== \"string\")\n                return option.value;\n              return option;\n            }\n          );\n          node.input(computedOptions);\n          previousValue = Array.isArray(node.value) ? node.value : [];\n          return;\n        }\n      });\n    };\n    const data = reactive({\n      twClasses: classes,\n      basicOptions: Array.from({ length: 15 }, (_, i) => `Option ${i + 1}`),\n      asyncLoader: async () => {\n        return await new Promise(() => {\n        });\n      },\n      paginatedLoader: async ({\n        page,\n        hasNextPage\n      }) => {\n        const base = (page - 1) * 10;\n        hasNextPage();\n        return Array.from({ length: 10 }, (_, i) => `Option ${base + i + 1}`);\n      },\n      formSubmitHandler: async (data2) => {\n        await new Promise((resolve) => setTimeout(resolve, 1e3));\n        alert(\"Form submitted (fake) — check console for data object\");\n        console.log(\"Form data:\", data2);\n      },\n      includes: (array, value) => {\n        if (!Array.isArray(array))\n          return false;\n        return array.includes(value);\n      },\n      checkboxPlugins: [selectAll],\n      filters: []\n    });\n    await Promise.all(promises);\n    const inputKeys = Object.keys(schemas);\n    const formNames = inputKeys.map((key) => {\n      if (key.startsWith(\"form/\")) {\n        switch (key) {\n          case \"form/tshirt\":\n            return {\n              id: key,\n              name: \"Order Form\"\n            };\n          default:\n            const name = key.replace(\"form/\", \"\");\n            return {\n              id: key,\n              name: name.charAt(0).toUpperCase() + name.slice(1) + \" Form\"\n            };\n        }\n      }\n      return {\n        id: key,\n        name: \"\"\n      };\n    });\n    const filteredFormNames = formNames.filter((form) => form.name !== \"\");\n    const forms = inputKeys.filter((schema) => {\n      return schema.startsWith(\"form/\");\n    });\n    const inputs = inputKeys.filter(\n      (schema) => !schema.startsWith(\"form/\")\n    );\n    const tabs = [];\n    if (inputs.length) {\n      tabs.push({\n        id: \"kitchen-sink\",\n        name: \"Kitchen Sink\"\n      });\n    }\n    if (forms.length) {\n      tabs.push(...filteredFormNames.sort((a, b) => a.name > b.name ? 1 : -1));\n    }\n    if (tabs.length) {\n      activeTab.value = tabs[0].id;\n    }\n    const kitchenSinkRenders = computed(() => {\n      inputs.sort();\n      const schemaDefinitions = inputs.reduce(\n        (schemaDefinitions2, inputName) => {\n          const schemaDefinition = schemas[inputName];\n          schemaDefinitions2.push({\n            $el: \"div\",\n            if: '$includes($filters, \"' + inputName + '\")',\n            attrs: {\n              key: inputName,\n              class: \"$twClasses.inputSection\",\n              \"data-type\": inputName\n            },\n            children: [\n              {\n                $el: \"h2\",\n                attrs: {\n                  class: \"$twClasses.inputType\"\n                },\n                children: inputName\n              },\n              {\n                $el: \"div\",\n                attrs: {\n                  class: \"$twClasses.specimenGroup\"\n                },\n                children: [\n                  ...(Array.isArray(schemaDefinition) ? schemaDefinition : [schemaDefinition]).map((specimen) => {\n                    return {\n                      $el: \"div\",\n                      attrs: {\n                        class: \"$twClasses.specimen\"\n                      },\n                      children: [specimen]\n                    };\n                  })\n                ]\n              }\n            ]\n          });\n          return schemaDefinitions2;\n        },\n        []\n      );\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            return activeTab.value === \"kitchen-sink\" ? h(FormKitSchema, { schema: schemaDefinitions, data }) : null;\n          }\n        }\n      );\n    });\n    const formRenders = computed(() => {\n      return filteredFormNames.map((form) => {\n        const schemaDefinition = schemas[form.id];\n        return h(\n          \"div\",\n          {\n            key: form.id\n          },\n          activeTab.value === form.id ? [\n            h(\n              \"div\",\n              {\n                class: classes.formContainer\n              },\n              [\n                h(FormKitSchema, {\n                  schema: schemaDefinition[0],\n                  data\n                })\n              ]\n            )\n          ] : \"\"\n        );\n      }).filter((form) => form.children);\n    });\n    const tabBar = computed(() => {\n      return h(\n        \"div\",\n        {\n          key: \"tab-bar\",\n          class: classes.tabs\n        },\n        tabs.map((tab) => {\n          return h(\n            \"span\",\n            {\n              class: classes.tab,\n              key: tab.id,\n              \"data-tab\": tab.id,\n              \"data-active\": activeTab.value === tab.id || void 0,\n              onClick: () => {\n                activeTab.value = tab.id;\n              }\n            },\n            tab.name\n          );\n        })\n      );\n    });\n    const filterCheckboxes = computed(() => {\n      const createCheckboxSchema = (inputGroup) => {\n        return {\n          $el: \"div\",\n          attrs: {\n            class: \"$twClasses.filterGroup\"\n          },\n          children: [\n            {\n              $formkit: \"checkbox\",\n              name: inputGroup.name,\n              label: inputGroup.label,\n              plugins: \"$checkboxPlugins\",\n              value: [\"all\"],\n              options: [\n                {\n                  label: \"All\",\n                  value: \"all\"\n                },\n                ...Array.isArray(inputGroup.inputs) ? inputGroup.inputs : []\n              ]\n            }\n          ]\n        };\n      };\n      const filterSchema = h(FormKitSchema, {\n        key: \"filter-checkboxes\",\n        data,\n        schema: {\n          $formkit: \"group\",\n          id: \"filter-checkboxes\",\n          children: [\n            {\n              $el: \"div\",\n              attrs: {\n                class: \"$twClasses.filterContainer\"\n              },\n              children: Object.keys(inputCheckboxes.value).map((key) => {\n                const inputGroup = inputCheckboxes.value[key];\n                return createCheckboxSchema(inputGroup);\n              })\n            }\n          ]\n        }\n      });\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            if (!(tabs.find((tab) => tab.id === \"kitchen-sink\") && activeTab.value === \"kitchen-sink\")) {\n              return null;\n            }\n            return filterSchema;\n          }\n        }\n      );\n    });\n    return () => {\n      return h(\n        \"div\",\n        {\n          class: classes.container\n        },\n        [\n          tabs.length > 1 ? tabBar.value : void 0,\n          filterCheckboxes.value,\n          ...formRenders.value,\n          kitchenSinkRenders.value\n        ]\n      );\n    };\n  }\n});\nvar messages = createSection(\"messages\", () => ({\n  $el: \"ul\",\n  if: \"$fns.length($messages)\"\n}));\nvar message = createSection(\"message\", () => ({\n  $el: \"li\",\n  for: [\"message\", \"$messages\"],\n  attrs: {\n    key: \"$message.key\",\n    id: `$id + '-' + $message.key`,\n    \"data-message-type\": \"$message.type\"\n  }\n}));\nvar definition = messages(message(\"$message.value\"));\nvar FormKitMessages = /* @__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object,\n      required: false\n    },\n    sectionsSchema: {\n      type: Object,\n      default: {}\n    },\n    defaultPosition: {\n      type: [String, Boolean],\n      default: false\n    }\n  },\n  setup(props, context) {\n    const node = computed(() => {\n      return props.node || inject(parentSymbol, void 0);\n    });\n    watch(\n      node,\n      () => {\n        if (node.value?.context && !undefine(props.defaultPosition)) {\n          node.value.context.defaultMessagePlacement = false;\n        }\n      },\n      { immediate: true }\n    );\n    const schema = definition(props.sectionsSchema || {});\n    const data = computed(() => {\n      return {\n        messages: node.value?.context?.messages || {},\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {}\n      };\n    });\n    return () => node.value?.context ? h(FormKitSchema_default, { schema, data: data.value }, { ...context.slots }) : null;\n  }\n});\nfunction useConfig(config) {\n  const options = Object.assign(\n    {\n      alias: \"FormKit\",\n      schemaAlias: \"FormKitSchema\"\n    },\n    typeof config === \"function\" ? config() : config\n  );\n  const rootConfig = createConfig(options.config || {});\n  options.config = { rootConfig };\n  provide(optionsSymbol, options);\n  provide(configSymbol, rootConfig);\n  if (typeof window !== \"undefined\") {\n    globalThis.__FORMKIT_CONFIGS__ = (globalThis.__FORMKIT_CONFIGS__ || []).concat([rootConfig]);\n  }\n}\nvar FormKitProvider = /* @__PURE__ */ defineComponent(\n  function FormKitProvider2(props, { slots, attrs }) {\n    const options = {};\n    if (props.config) {\n      useConfig(props.config);\n    }\n    return () => slots.default ? slots.default(options).map((vnode) => {\n      return h(vnode, {\n        ...attrs,\n        ...vnode.props\n      });\n    }) : null;\n  },\n  { props: [\"config\"], name: \"FormKitProvider\", inheritAttrs: false }\n);\nvar FormKitConfigLoader = /* @__PURE__ */ defineComponent(\n  async function FormKitConfigLoader2(props, context) {\n    let config = {};\n    if (props.configFile) {\n      const configFile = await import(\n        \"/Users/sebastianwessel/projekte/voyage/formkit.config.ts\");\n      config = \"default\" in configFile ? configFile.default : configFile;\n    }\n    if (typeof config === \"function\") {\n      config = config();\n    }\n    const useDefaultConfig = props.defaultConfig ?? true;\n    if (useDefaultConfig) {\n      const { defaultConfig: defaultConfig2 } = await Promise.resolve().then(() => (init_defaultConfig(), defaultConfig_exports));\n      config = /* @__PURE__ */ defaultConfig2(config);\n    }\n    return () => h(FormKitProvider, { ...context.attrs, config }, context.slots);\n  },\n  {\n    props: [\"defaultConfig\", \"configFile\"],\n    inheritAttrs: false\n  }\n);\nvar FormKitLazyProvider = /* @__PURE__ */ defineComponent(\n  function FormKitLazyProvider2(props, context) {\n    const config = inject(optionsSymbol, null);\n    const passthru = (vnode) => {\n      return h(vnode, {\n        ...context.attrs,\n        ...vnode.props\n      });\n    };\n    if (config) {\n      return () => context.slots?.default ? context.slots.default().map(passthru) : null;\n    }\n    const instance = getCurrentInstance();\n    if (instance.suspense) {\n      return () => h(FormKitConfigLoader, props, {\n        default: () => context.slots?.default ? context.slots.default().map(passthru) : null\n      });\n    }\n    return () => h(Suspense, null, {\n      ...context.slots,\n      default: () => h(FormKitConfigLoader, { ...context.attrs, ...props }, context.slots)\n    });\n  },\n  {\n    props: [\"defaultConfig\", \"configFile\"],\n    inheritAttrs: false\n  }\n);\nvar summary = createSection(\"summary\", () => ({\n  $el: \"div\",\n  attrs: {\n    \"aria-live\": \"polite\"\n  }\n}));\nvar summaryInner = createSection(\"summaryInner\", () => ({\n  $el: \"div\",\n  if: \"$summaries.length && $showSummaries\"\n}));\nvar messages2 = createSection(\"messages\", () => ({\n  $el: \"ul\",\n  if: \"$summaries.length && $showSummaries\"\n}));\nvar message2 = createSection(\"message\", () => ({\n  $el: \"li\",\n  for: [\"summary\", \"$summaries\"],\n  attrs: {\n    key: \"$summary.key\",\n    \"data-message-type\": \"$summary.type\"\n  }\n}));\nvar summaryHeader = createSection(\"summaryHeader\", () => ({\n  $el: \"h2\",\n  attrs: {\n    id: \"$id\"\n  }\n}));\nvar messageLink = createSection(\"messageLink\", () => ({\n  $el: \"a\",\n  attrs: {\n    id: \"$summary.key\",\n    href: '$: \"#\" + $summary.id',\n    onClick: \"$jumpLink\"\n  }\n}));\nvar definition2 = summary(\n  summaryInner(\n    summaryHeader(\"$summaryHeader\"),\n    messages2(message2(messageLink(\"$summary.message\")))\n  )\n);\nvar FormKitSummary = /* @__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object,\n      required: false\n    },\n    forceShow: {\n      type: Boolean,\n      default: false\n    },\n    sectionsSchema: {\n      type: Object,\n      default: {}\n    }\n  },\n  emits: {\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    show: (_summaries) => true\n  },\n  setup(props, context) {\n    const id = `summary-${token()}`;\n    const node = computed(() => {\n      return props.node || inject(parentSymbol, void 0);\n    });\n    if (!node)\n      throw new Error(\n        \"FormKitSummary must have a FormKit parent or use the node prop.\"\n      );\n    const summaryContexts = ref([]);\n    const showSummaries = ref(false);\n    const summaries = computed(() => {\n      const summarizedMessages = [];\n      summaryContexts.value.forEach((context2) => {\n        for (const idx in context2.messages) {\n          const message3 = context2.messages[idx];\n          if (typeof message3.value !== \"string\")\n            continue;\n          summarizedMessages.push({\n            message: message3.value,\n            id: context2.id,\n            key: `${context2.id}-${message3.key}`,\n            type: message3.type\n          });\n        }\n      });\n      return summarizedMessages;\n    });\n    const addContexts = () => {\n      summaryContexts.value = [];\n      node.value?.walk(\n        (child) => child.context && summaryContexts.value.push(child.context)\n      );\n    };\n    node.value?.on(\"submit-raw\", async () => {\n      addContexts();\n      if (summaries.value.length === 0)\n        return;\n      context.emit(\"show\", summaries.value);\n      showSummaries.value = true;\n      await nextTick();\n      if (typeof window !== \"undefined\") {\n        document.getElementById(id)?.scrollIntoView({ behavior: \"smooth\" });\n        if (summaries.value[0]) {\n          document.getElementById(summaries.value[0].key)?.focus();\n        }\n      }\n    });\n    node.value?.on(\"child\", addContexts);\n    function jumpLink(e) {\n      if (e.target instanceof HTMLAnchorElement) {\n        e.preventDefault();\n        const id2 = e.target.getAttribute(\"href\")?.substring(1);\n        if (id2) {\n          document.getElementById(id2)?.scrollIntoView({ behavior: \"smooth\" });\n          document.getElementById(id2)?.focus();\n        }\n      }\n    }\n    localize(\"summaryHeader\", \"There were errors in your form.\")(node.value);\n    const schema = definition2(props.sectionsSchema || {});\n    const data = computed(() => {\n      return {\n        id,\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {},\n        summaries: summaries.value,\n        showSummaries: props.forceShow || showSummaries.value,\n        summaryHeader: node.value?.context?.ui?.summaryHeader?.value || \"\",\n        jumpLink\n      };\n    });\n    return () => node.value?.context ? h(FormKitSchema_default, { schema, data: data.value }, { ...context.slots }) : null;\n  }\n});\n\n// packages/vue/src/index.ts\ninit_defaultConfig();\ninit_bindings();\nvar FormKitIcon = /* @__PURE__ */ defineComponent({\n  name: \"FormKitIcon\",\n  props: {\n    icon: {\n      type: String,\n      default: \"\"\n    },\n    iconLoader: {\n      type: Function,\n      default: null\n    },\n    iconLoaderUrl: {\n      type: Function,\n      default: null\n    }\n  },\n  setup(props) {\n    const icon = ref(void 0);\n    const config = inject(optionsSymbol, {});\n    const parent = inject(parentSymbol, null);\n    let iconHandler = void 0;\n    function loadIcon() {\n      if (!iconHandler || typeof iconHandler !== \"function\")\n        return;\n      const iconOrPromise = iconHandler(props.icon);\n      if (iconOrPromise instanceof Promise) {\n        iconOrPromise.then((iconValue) => {\n          icon.value = iconValue;\n        });\n      } else {\n        icon.value = iconOrPromise;\n      }\n    }\n    if (props.iconLoader && typeof props.iconLoader === \"function\") {\n      iconHandler = createIconHandler(props.iconLoader);\n    } else if (parent && parent.props?.iconLoader) {\n      iconHandler = createIconHandler(parent.props.iconLoader);\n    } else if (props.iconLoaderUrl && typeof props.iconLoaderUrl === \"function\") {\n      iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl);\n    } else {\n      const iconPlugin = config?.plugins?.find((plugin2) => {\n        return typeof plugin2.iconHandler === \"function\";\n      });\n      if (iconPlugin) {\n        iconHandler = iconPlugin.iconHandler;\n      }\n    }\n    watch(\n      () => props.icon,\n      () => {\n        loadIcon();\n      },\n      { immediate: true }\n    );\n    return () => {\n      if (props.icon && icon.value) {\n        return h(\"span\", {\n          class: \"formkit-icon\",\n          innerHTML: icon.value\n        });\n      }\n      return null;\n    };\n  }\n});\n\nexport { FormKit_default as FormKit, FormKitIcon, FormKitKitchenSink, FormKitLazyProvider, FormKitMessages, FormKitProvider, FormKitRoot, FormKitSchema, FormKitSummary, bindings_default as bindings, componentSymbol, configSymbol, createInput, defaultConfig, defineFormKitConfig, getCurrentSchemaNode, onSSRComplete, optionsSymbol, parentSymbol, plugin, rootSymbol, ssrComplete, useConfig, useInput };\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "pre",
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1709718915854,
      "end": 1709718915854,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1709718915854,
      "end": 1709718915855,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "post"
    },
    {
      "name": "element-plus:transform",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1709718915855,
      "end": 1709718915855,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "result": "import { __vitePreload } from \"\u0000vite/preload-helper.js\";import { defineComponent, getCurrentInstance, markRaw, watch, watchEffect, reactive, onMounted, onUnmounted, ref, provide, h, inject, computed, toRef, onBeforeUnmount, KeepAlive, Suspense, nextTick, triggerRef, isRef, isReactive, createTextVNode, resolveComponent } from 'vue';\nimport { createConfig, createNode, error, createMessage, getNode, clearErrors, setErrors, submitForm, reset, createClasses, generateClassList, warn, watchRegistry, isNode, sugar, isDOM, isComponent, isConditional, compile } from '@formkit/core';\nexport { clearErrors, errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';\nimport { cloneAny, extend, undefine, camel, kebab, nodeProps, only, except, oncePerTick, slugify, shallowClone, eq, token, isObject, empty, has, isPojo } from '@formkit/utils';\nimport { createObserver } from '@formkit/observer';\nimport * as defaultRules from '@formkit/rules';\nimport { createValidationPlugin } from '@formkit/validation';\nimport { createI18nPlugin, en } from '@formkit/i18n';\nexport { changeLocale } from '@formkit/i18n';\nimport { createSection, useSchema, localize, createLibraryPlugin, inputs, runtimeProps } from '@formkit/inputs';\nimport { createIconHandler, createThemePlugin } from '@formkit/themes';\nimport { register } from '@formkit/dev';\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar vueBindings, bindings_default;\nvar init_bindings = __esm({\n  \"packages/vue/src/bindings.ts\"() {\n    vueBindings = function vueBindings2(node) {\n      node.ledger.count(\"blocking\", (m) => m.blocking);\n      const isValid = ref(!node.ledger.value(\"blocking\"));\n      node.ledger.count(\"errors\", (m) => m.type === \"error\");\n      const hasErrors = ref(!!node.ledger.value(\"errors\"));\n      let hasTicked = false;\n      nextTick(() => {\n        hasTicked = true;\n      });\n      const availableMessages = reactive(\n        node.store.reduce((store, message3) => {\n          if (message3.visible) {\n            store[message3.key] = message3;\n          }\n          return store;\n        }, {})\n      );\n      const validationVisibility = ref(\n        node.props.validationVisibility || (node.props.type === \"checkbox\" ? \"dirty\" : \"blur\")\n      );\n      node.on(\"prop:validationVisibility\", ({ payload }) => {\n        validationVisibility.value = payload;\n      });\n      const hasShownErrors = ref(validationVisibility.value === \"live\");\n      const isRequired = ref(false);\n      const checkForRequired = (parsedRules) => {\n        isRequired.value = (parsedRules ?? []).some(\n          (rule) => rule.name === \"required\"\n        );\n      };\n      checkForRequired(node.props.parsedRules);\n      node.on(\"prop:parsedRules\", ({ payload }) => checkForRequired(payload));\n      const items = ref(node.children.map((child) => child.uid));\n      const validationVisible = computed(() => {\n        if (!context.state)\n          return false;\n        if (context.state.submitted)\n          return true;\n        if (!hasShownErrors.value && !context.state.settled) {\n          return false;\n        }\n        switch (validationVisibility.value) {\n          case \"live\":\n            return true;\n          case \"blur\":\n            return context.state.blurred;\n          case \"dirty\":\n            return context.state.dirty;\n          default:\n            return false;\n        }\n      });\n      const isComplete = computed(() => {\n        return context && hasValidation.value ? isValid.value && !hasErrors.value : context.state.dirty && !empty(context.value);\n      });\n      const hasValidation = ref(\n        Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0\n      );\n      node.on(\"prop:parsedRules\", ({ payload: rules }) => {\n        hasValidation.value = Array.isArray(rules) && rules.length > 0;\n      });\n      const messages3 = computed(() => {\n        const visibleMessages = {};\n        for (const key in availableMessages) {\n          const message3 = availableMessages[key];\n          if (message3.type !== \"validation\" || validationVisible.value) {\n            visibleMessages[key] = message3;\n          }\n        }\n        return visibleMessages;\n      });\n      const ui = reactive(\n        node.store.reduce((messages4, message3) => {\n          if (message3.type === \"ui\" && message3.visible)\n            messages4[message3.key] = message3;\n          return messages4;\n        }, {})\n      );\n      const cachedClasses = reactive({});\n      const classes2 = new Proxy(cachedClasses, {\n        get(...args) {\n          const [target, property] = args;\n          let className = Reflect.get(...args);\n          if (!className && typeof property === \"string\") {\n            if (!has(target, property) && !property.startsWith(\"__v\")) {\n              const observedNode = createObserver(node);\n              observedNode.watch((node2) => {\n                const rootClasses = typeof node2.config.rootClasses === \"function\" ? node2.config.rootClasses(property, node2) : {};\n                const globalConfigClasses = node2.config.classes ? createClasses(property, node2, node2.config.classes[property]) : {};\n                const classesPropClasses = createClasses(\n                  property,\n                  node2,\n                  node2.props[`_${property}Class`]\n                );\n                const sectionPropClasses = createClasses(\n                  property,\n                  node2,\n                  node2.props[`${property}Class`]\n                );\n                className = generateClassList(\n                  node2,\n                  property,\n                  rootClasses,\n                  globalConfigClasses,\n                  classesPropClasses,\n                  sectionPropClasses\n                );\n                target[property] = className ?? \"\";\n              });\n            }\n          }\n          return className;\n        }\n      });\n      node.on(\"prop:rootClasses\", () => {\n        const keys = Object.keys(cachedClasses);\n        for (const key of keys) {\n          delete cachedClasses[key];\n        }\n      });\n      const describedBy = computed(() => {\n        const describers = [];\n        if (context.help) {\n          describers.push(`help-${node.props.id}`);\n        }\n        for (const key in messages3.value) {\n          describers.push(`${node.props.id}-${key}`);\n        }\n        return describers.length ? describers.join(\" \") : void 0;\n      });\n      const value = ref(node.value);\n      const _value = ref(node.value);\n      const context = reactive({\n        _value,\n        attrs: node.props.attrs,\n        disabled: node.props.disabled,\n        describedBy,\n        fns: {\n          length: (obj) => Object.keys(obj).length,\n          number: (value2) => Number(value2),\n          string: (value2) => String(value2),\n          json: (value2) => JSON.stringify(value2),\n          eq: eq\n        },\n        handlers: {\n          blur: (e) => {\n            if (!node)\n              return;\n            node.store.set(\n              createMessage({ key: \"blurred\", visible: false, value: true })\n            );\n            if (typeof node.props.attrs.onBlur === \"function\") {\n              node.props.attrs.onBlur(e);\n            }\n          },\n          touch: () => {\n            const doCompare = context.dirtyBehavior === \"compare\";\n            if (node.store.dirty?.value && !doCompare)\n              return;\n            const isDirty = !eq(node.props._init, node._value);\n            if (!isDirty && !doCompare)\n              return;\n            node.store.set(\n              createMessage({ key: \"dirty\", visible: false, value: isDirty })\n            );\n          },\n          DOMInput: (e) => {\n            node.input(e.target.value);\n            node.emit(\"dom-input-event\", e);\n          }\n        },\n        help: node.props.help,\n        id: node.props.id,\n        items,\n        label: node.props.label,\n        messages: messages3,\n        didMount: false,\n        node: markRaw(node),\n        options: node.props.options,\n        defaultMessagePlacement: true,\n        slots: node.props.__slots,\n        state: {\n          blurred: false,\n          complete: isComplete,\n          dirty: false,\n          empty: empty(value),\n          submitted: false,\n          settled: node.isSettled,\n          valid: isValid,\n          errors: hasErrors,\n          rules: hasValidation,\n          validationVisible,\n          required: isRequired\n        },\n        type: node.props.type,\n        family: node.props.family,\n        ui,\n        value,\n        classes: classes2\n      });\n      node.on(\"created\", () => {\n        if (!eq(context.value, node.value)) {\n          _value.value = node.value;\n          value.value = node.value;\n          triggerRef(value);\n          triggerRef(_value);\n        }\n        (async () => {\n          await node.settled;\n          if (node)\n            node.props._init = cloneAny(node.value);\n        })();\n      });\n      node.on(\"mounted\", () => {\n        context.didMount = true;\n      });\n      node.on(\"settled\", ({ payload: isSettled }) => {\n        context.state.settled = isSettled;\n      });\n      function observeProps(observe) {\n        const propNames = Array.isArray(observe) ? observe : Object.keys(observe);\n        propNames.forEach((prop) => {\n          prop = camel(prop);\n          if (!has(context, prop)) {\n            context[prop] = node.props[prop];\n          }\n          node.on(`prop:${prop}`, ({ payload }) => {\n            context[prop] = payload;\n          });\n        });\n      }\n      const rootProps = () => {\n        const props = [\n          \"__root\",\n          \"help\",\n          \"label\",\n          \"disabled\",\n          \"options\",\n          \"type\",\n          \"attrs\",\n          \"preserve\",\n          \"preserveErrors\",\n          \"id\",\n          \"dirtyBehavior\"\n        ];\n        const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/;\n        const matchingProps = Object.keys(node.props).filter((prop) => {\n          return iconPattern.test(prop);\n        });\n        return props.concat(matchingProps);\n      };\n      observeProps(rootProps());\n      function definedAs(definition3) {\n        if (definition3.props)\n          observeProps(definition3.props);\n      }\n      node.props.definition && definedAs(node.props.definition);\n      node.on(\"added-props\", ({ payload }) => observeProps(payload));\n      node.on(\"input\", ({ payload }) => {\n        if (node.type !== \"input\" && !isRef(payload) && !isReactive(payload)) {\n          _value.value = shallowClone(payload);\n        } else {\n          _value.value = payload;\n          triggerRef(_value);\n        }\n      });\n      node.on(\"commitRaw\", ({ payload }) => {\n        if (node.type !== \"input\" && !isRef(payload) && !isReactive(payload)) {\n          value.value = _value.value = shallowClone(payload);\n        } else {\n          value.value = _value.value = payload;\n          triggerRef(value);\n        }\n        node.emit(\"modelUpdated\");\n      });\n      node.on(\"commit\", ({ payload }) => {\n        if ((!context.state.dirty || context.dirtyBehavior === \"compare\") && node.isCreated && hasTicked) {\n          if (!node.store.validating?.value) {\n            context.handlers.touch();\n          } else {\n            const receipt = node.on(\"message-removed\", ({ payload: message3 }) => {\n              if (message3.key === \"validating\") {\n                context.handlers.touch();\n                node.off(receipt);\n              }\n            });\n          }\n        }\n        if (isComplete && node.type === \"input\" && hasErrors.value && !undefine(node.props.preserveErrors)) {\n          node.store.filter(\n            (message3) => !(message3.type === \"error\" && message3.meta?.autoClear === true)\n          );\n        }\n        if (node.type === \"list\" && node.sync) {\n          items.value = node.children.map((child) => child.uid);\n        }\n        context.state.empty = empty(payload);\n      });\n      const updateState = async (message3) => {\n        if (message3.type === \"ui\" && message3.visible && !message3.meta.showAsMessage) {\n          ui[message3.key] = message3;\n        } else if (message3.visible) {\n          availableMessages[message3.key] = message3;\n        } else if (message3.type === \"state\") {\n          context.state[message3.key] = !!message3.value;\n        }\n      };\n      node.on(\"message-added\", (e) => updateState(e.payload));\n      node.on(\"message-updated\", (e) => updateState(e.payload));\n      node.on(\"message-removed\", ({ payload: message3 }) => {\n        delete ui[message3.key];\n        delete availableMessages[message3.key];\n        delete context.state[message3.key];\n      });\n      node.on(\"settled:blocking\", () => {\n        isValid.value = true;\n      });\n      node.on(\"unsettled:blocking\", () => {\n        isValid.value = false;\n      });\n      node.on(\"settled:errors\", () => {\n        hasErrors.value = false;\n      });\n      node.on(\"unsettled:errors\", () => {\n        hasErrors.value = true;\n      });\n      watch(validationVisible, (value2) => {\n        if (value2) {\n          hasShownErrors.value = true;\n        }\n      });\n      node.context = context;\n      node.emit(\"context\", node, false);\n      node.on(\"destroyed\", () => {\n        node.context = void 0;\n        node = null;\n      });\n    };\n    bindings_default = vueBindings;\n  }\n});\n\n// packages/vue/src/defaultConfig.ts\nvar defaultConfig_exports = {};\n__export(defaultConfig_exports, {\n  defaultConfig: () => defaultConfig\n});\nvar defaultConfig;\nvar init_defaultConfig = __esm({\n  \"packages/vue/src/defaultConfig.ts\"() {\n    init_bindings();\n    defaultConfig = (options = {}) => {\n      register();\n      const {\n        rules = {},\n        locales = {},\n        inputs: inputs$1 = {},\n        messages: messages3 = {},\n        locale = void 0,\n        theme = void 0,\n        iconLoaderUrl = void 0,\n        iconLoader = void 0,\n        icons = {},\n        ...nodeOptions\n      } = options;\n      const validation = createValidationPlugin({\n        ...defaultRules,\n        ...rules || {}\n      });\n      const i18n = createI18nPlugin(\n        extend({ en, ...locales || {} }, messages3)\n      );\n      const library = createLibraryPlugin(inputs, inputs$1);\n      const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader);\n      return extend(\n        {\n          plugins: [library, themePlugin, bindings_default, i18n, validation],\n          ...!locale ? {} : { config: { locale } }\n        },\n        nodeOptions || {},\n        true\n      );\n    };\n  }\n});\n\n// packages/vue/src/composables/onSSRComplete.ts\nvar isServer = typeof window === \"undefined\";\nvar ssrCompleteRegistry = /* @__PURE__ */ new Map();\nfunction ssrComplete(app) {\n  if (!isServer)\n    return;\n  const callbacks = ssrCompleteRegistry.get(app);\n  if (!callbacks)\n    return;\n  for (const callback of callbacks) {\n    callback();\n  }\n  callbacks.clear();\n  ssrCompleteRegistry.delete(app);\n}\nfunction onSSRComplete(app, callback) {\n  if (!isServer || !app)\n    return;\n  if (!ssrCompleteRegistry.has(app))\n    ssrCompleteRegistry.set(app, /* @__PURE__ */ new Set());\n  ssrCompleteRegistry.get(app)?.add(callback);\n}\n\n// packages/vue/src/FormKitSchema.ts\nvar isServer2 = typeof window === \"undefined\";\nvar memo = {};\nvar memoKeys = {};\nvar instanceKey;\nvar instanceScopes = /* @__PURE__ */ new WeakMap();\nvar raw = \"__raw__\";\nvar isClassProp = /[a-zA-Z0-9\\-][cC]lass$/;\nfunction getRef(token3, data) {\n  const value = ref(null);\n  if (token3 === \"get\") {\n    const nodeRefs = {};\n    value.value = get.bind(null, nodeRefs);\n    return value;\n  }\n  const path = token3.split(\".\");\n  watchEffect(() => {\n    value.value = getValue(\n      isRef(data) ? data.value : data,\n      path\n    );\n  });\n  return value;\n}\nfunction getValue(set, path) {\n  if (Array.isArray(set)) {\n    for (const subset of set) {\n      const value = subset !== false && getValue(subset, path);\n      if (value !== void 0)\n        return value;\n    }\n    return void 0;\n  }\n  let foundValue = void 0;\n  let obj = set;\n  for (const i in path) {\n    const key = path[i];\n    if (typeof obj !== \"object\" || obj === null) {\n      foundValue = void 0;\n      break;\n    }\n    const currentValue = obj[key];\n    if (Number(i) === path.length - 1 && currentValue !== void 0) {\n      foundValue = typeof currentValue === \"function\" ? currentValue.bind(obj) : currentValue;\n      break;\n    }\n    obj = currentValue;\n  }\n  return foundValue;\n}\nfunction get(nodeRefs, id) {\n  if (typeof id !== \"string\")\n    return warn(650);\n  if (!(id in nodeRefs))\n    nodeRefs[id] = ref(void 0);\n  if (nodeRefs[id].value === void 0) {\n    nodeRefs[id].value = null;\n    const root = getNode(id);\n    if (root)\n      nodeRefs[id].value = root.context;\n    watchRegistry(id, ({ payload: node }) => {\n      nodeRefs[id].value = isNode(node) ? node.context : node;\n    });\n  }\n  return nodeRefs[id].value;\n}\nfunction parseSchema(library, schema, memoKey) {\n  function parseCondition(library2, node) {\n    const condition = provider(compile(node.if), { if: true });\n    const children = createElements(library2, node.then);\n    const alternate = node.else ? createElements(library2, node.else) : null;\n    return [condition, children, alternate];\n  }\n  function parseConditionAttr(attr, _default) {\n    const condition = provider(compile(attr.if));\n    let b = () => _default;\n    let a = () => _default;\n    if (typeof attr.then === \"object\") {\n      a = parseAttrs(attr.then, void 0);\n    } else if (typeof attr.then === \"string\" && attr.then?.startsWith(\"$\")) {\n      a = provider(compile(attr.then));\n    } else {\n      a = () => attr.then;\n    }\n    if (has(attr, \"else\")) {\n      if (typeof attr.else === \"object\") {\n        b = parseAttrs(attr.else);\n      } else if (typeof attr.else === \"string\" && attr.else?.startsWith(\"$\")) {\n        b = provider(compile(attr.else));\n      } else {\n        b = () => attr.else;\n      }\n    }\n    return () => condition() ? a() : b();\n  }\n  function parseAttrs(unparsedAttrs, bindExp, _default = {}) {\n    const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));\n    const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});\n    const setters = [\n      (attrs) => {\n        const bound = boundAttrs();\n        for (const attr in bound) {\n          if (!explicitAttrs.has(attr)) {\n            attrs[attr] = bound[attr];\n          }\n        }\n      }\n    ];\n    if (unparsedAttrs) {\n      if (isConditional(unparsedAttrs)) {\n        const condition = parseConditionAttr(\n          unparsedAttrs,\n          _default\n        );\n        return condition;\n      }\n      for (let attr in unparsedAttrs) {\n        const value = unparsedAttrs[attr];\n        let getValue2;\n        const isStr = typeof value === \"string\";\n        if (attr.startsWith(raw)) {\n          attr = attr.substring(7);\n          getValue2 = () => value;\n        } else if (isStr && value.startsWith(\"$\") && value.length > 1 && !(value.startsWith(\"$reset\") && isClassProp.test(attr))) {\n          getValue2 = provider(compile(value));\n        } else if (typeof value === \"object\" && isConditional(value)) {\n          getValue2 = parseConditionAttr(value, void 0);\n        } else if (typeof value === \"object\" && isPojo(value)) {\n          getValue2 = parseAttrs(value);\n        } else {\n          getValue2 = () => value;\n        }\n        setters.push((attrs) => {\n          attrs[attr] = getValue2();\n        });\n      }\n    }\n    return () => {\n      const attrs = Array.isArray(unparsedAttrs) ? [] : {};\n      setters.forEach((setter) => setter(attrs));\n      return attrs;\n    };\n  }\n  function parseNode(library2, _node) {\n    let element = null;\n    let attrs = () => null;\n    let condition = false;\n    let children = null;\n    let alternate = null;\n    let iterator = null;\n    let resolve = false;\n    const node = sugar(_node);\n    if (isDOM(node)) {\n      element = node.$el;\n      attrs = node.$el !== \"text\" ? parseAttrs(node.attrs, node.bind) : () => null;\n    } else if (isComponent(node)) {\n      if (typeof node.$cmp === \"string\") {\n        if (has(library2, node.$cmp)) {\n          element = library2[node.$cmp];\n        } else {\n          element = node.$cmp;\n          resolve = true;\n        }\n      } else {\n        element = node.$cmp;\n      }\n      attrs = parseAttrs(node.props, node.bind);\n    } else if (isConditional(node)) {\n      [condition, children, alternate] = parseCondition(library2, node);\n    }\n    if (!isConditional(node) && \"if\" in node) {\n      condition = provider(compile(node.if));\n    } else if (!isConditional(node) && element === null) {\n      condition = () => true;\n    }\n    if (\"children\" in node && node.children) {\n      if (typeof node.children === \"string\") {\n        if (node.children.startsWith(\"$slots.\")) {\n          element = element === \"text\" ? \"slot\" : element;\n          children = provider(compile(node.children));\n        } else if (node.children.startsWith(\"$\") && node.children.length > 1) {\n          const value = provider(compile(node.children));\n          children = () => String(value());\n        } else {\n          children = () => String(node.children);\n        }\n      } else if (Array.isArray(node.children)) {\n        children = createElements(library2, node.children);\n      } else {\n        const [childCondition, c, a] = parseCondition(library2, node.children);\n        children = (iterationData) => childCondition && childCondition() ? c && c(iterationData) : a && a(iterationData);\n      }\n    }\n    if (isComponent(node)) {\n      if (children) {\n        const produceChildren = children;\n        children = (iterationData) => {\n          return {\n            default(slotData2, key) {\n              const currentKey = instanceKey;\n              if (key)\n                instanceKey = key;\n              if (slotData2)\n                instanceScopes.get(instanceKey)?.unshift(slotData2);\n              if (iterationData)\n                instanceScopes.get(instanceKey)?.unshift(iterationData);\n              const c = produceChildren(iterationData);\n              if (slotData2)\n                instanceScopes.get(instanceKey)?.shift();\n              if (iterationData)\n                instanceScopes.get(instanceKey)?.shift();\n              instanceKey = currentKey;\n              return c;\n            }\n          };\n        };\n        children.slot = true;\n      } else {\n        children = () => ({});\n      }\n    }\n    if (\"for\" in node && node.for) {\n      const values = node.for.length === 3 ? node.for[2] : node.for[1];\n      const getValues = typeof values === \"string\" && values.startsWith(\"$\") ? provider(compile(values)) : () => values;\n      iterator = [\n        getValues,\n        node.for[0],\n        node.for.length === 3 ? String(node.for[1]) : null\n      ];\n    }\n    return [condition, element, attrs, children, alternate, iterator, resolve];\n  }\n  function createSlots(children, iterationData) {\n    const slots = children(iterationData);\n    const currentKey = instanceKey;\n    return Object.keys(slots).reduce((allSlots, slotName) => {\n      const slotFn = slots && slots[slotName];\n      allSlots[slotName] = (data) => {\n        return slotFn && slotFn(data, currentKey) || null;\n      };\n      return allSlots;\n    }, {});\n  }\n  function createElement(library2, node) {\n    const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library2, node);\n    let createNodes = (iterationData) => {\n      if (condition && element === null && children) {\n        return condition() ? children(iterationData) : alternate && alternate(iterationData);\n      }\n      if (element && (!condition || condition())) {\n        if (element === \"text\" && children) {\n          return createTextVNode(String(children()));\n        }\n        if (element === \"slot\" && children)\n          return children(iterationData);\n        const el = resolve ? resolveComponent(element) : element;\n        const slots = children?.slot ? createSlots(children, iterationData) : null;\n        return h(\n          el,\n          attrs(),\n          slots || (children ? children(iterationData) : [])\n        );\n      }\n      return typeof alternate === \"function\" ? alternate(iterationData) : alternate;\n    };\n    if (iterator) {\n      const repeatedNode = createNodes;\n      const [getValues, valueName, keyName] = iterator;\n      createNodes = () => {\n        const _v = getValues();\n        const values = Number.isFinite(_v) ? Array(Number(_v)).fill(0).map((_, i) => i) : _v;\n        const fragment = [];\n        if (typeof values !== \"object\")\n          return null;\n        const instanceScope = instanceScopes.get(instanceKey) || [];\n        const isArray = Array.isArray(values);\n        for (const key in values) {\n          if (isArray && key in Array.prototype)\n            continue;\n          const iterationData = Object.defineProperty(\n            {\n              ...instanceScope.reduce(\n                (previousIterationData, scopedData) => {\n                  if (previousIterationData.__idata) {\n                    return { ...previousIterationData, ...scopedData };\n                  }\n                  return scopedData;\n                },\n                {}\n              ),\n              [valueName]: values[key],\n              ...keyName !== null ? { [keyName]: isArray ? Number(key) : key } : {}\n            },\n            \"__idata\",\n            { enumerable: false, value: true }\n          );\n          instanceScope.unshift(iterationData);\n          fragment.push(repeatedNode.bind(null, iterationData)());\n          instanceScope.shift();\n        }\n        return fragment;\n      };\n    }\n    return createNodes;\n  }\n  function createElements(library2, schema2) {\n    if (Array.isArray(schema2)) {\n      const els = schema2.map(createElement.bind(null, library2));\n      return (iterationData) => els.map((element2) => element2(iterationData));\n    }\n    const element = createElement(library2, schema2);\n    return (iterationData) => element(iterationData);\n  }\n  const providers = [];\n  function provider(compiled, hints = {}) {\n    const compiledFns = /* @__PURE__ */ new WeakMap();\n    providers.push((callback, key) => {\n      compiledFns.set(\n        key,\n        compiled.provide((tokens) => callback(tokens, hints))\n      );\n    });\n    return () => compiledFns.get(instanceKey)();\n  }\n  function createInstance(providerCallback, key) {\n    memoKey ?? (memoKey = toMemoKey(schema));\n    const [render, compiledProviders] = has(memo, memoKey) ? memo[memoKey] : [createElements(library, schema), providers];\n    if (!isServer2) {\n      memoKeys[memoKey] ?? (memoKeys[memoKey] = 0);\n      memoKeys[memoKey]++;\n      memo[memoKey] = [render, compiledProviders];\n    }\n    compiledProviders.forEach((compiledProvider) => {\n      compiledProvider(providerCallback, key);\n    });\n    return () => {\n      instanceKey = key;\n      return render();\n    };\n  }\n  return createInstance;\n}\nfunction useScope(token3, defaultValue) {\n  const scopedData = instanceScopes.get(instanceKey) || [];\n  let scopedValue = void 0;\n  if (scopedData.length) {\n    scopedValue = getValue(scopedData, token3.split(\".\"));\n  }\n  return scopedValue === void 0 ? defaultValue : scopedValue;\n}\nfunction slotData(data, key) {\n  return new Proxy(data, {\n    get(...args) {\n      let data2 = void 0;\n      const property = args[1];\n      if (typeof property === \"string\") {\n        const prevKey = instanceKey;\n        instanceKey = key;\n        data2 = useScope(property, void 0);\n        instanceKey = prevKey;\n      }\n      return data2 !== void 0 ? data2 : Reflect.get(...args);\n    }\n  });\n}\nfunction createRenderFn(instanceCreator, data, instanceKey2) {\n  return instanceCreator(\n    (requirements, hints = {}) => {\n      return requirements.reduce((tokens, token3) => {\n        if (token3.startsWith(\"slots.\")) {\n          const slot = token3.substring(6);\n          const hasSlot = () => data.slots && has(data.slots, slot) && typeof data.slots[slot] === \"function\";\n          if (hints.if) {\n            tokens[token3] = hasSlot;\n          } else if (data.slots) {\n            const scopedData = slotData(data, instanceKey2);\n            tokens[token3] = () => hasSlot() ? data.slots[slot](scopedData) : null;\n          }\n        } else {\n          const value = getRef(token3, data);\n          tokens[token3] = () => useScope(token3, value.value);\n        }\n        return tokens;\n      }, {});\n    },\n    instanceKey2\n  );\n}\nfunction clean(schema, memoKey, instanceKey2) {\n  memoKey ?? (memoKey = toMemoKey(schema));\n  memoKeys[memoKey]--;\n  if (memoKeys[memoKey] === 0) {\n    delete memoKeys[memoKey];\n    const [, providers] = memo[memoKey];\n    delete memo[memoKey];\n    providers.length = 0;\n  }\n  instanceScopes.delete(instanceKey2);\n}\nfunction toMemoKey(schema) {\n  return JSON.stringify(schema, (_, value) => {\n    if (typeof value === \"function\") {\n      return value.toString();\n    }\n    return value;\n  });\n}\nvar FormKitSchema = /* @__PURE__ */ defineComponent({\n  name: \"FormKitSchema\",\n  props: {\n    schema: {\n      type: [Array, Object],\n      required: true\n    },\n    data: {\n      type: Object,\n      default: () => ({})\n    },\n    library: {\n      type: Object,\n      default: () => ({})\n    },\n    memoKey: {\n      type: String,\n      required: false\n    }\n  },\n  emits: [\"mounted\"],\n  setup(props, context) {\n    const instance = getCurrentInstance();\n    let instanceKey2 = {};\n    instanceScopes.set(instanceKey2, []);\n    const library = { FormKit: markRaw(FormKit_default), ...props.library };\n    let provider = parseSchema(library, props.schema, props.memoKey);\n    let render;\n    let data;\n    if (!isServer2) {\n      watch(\n        () => props.schema,\n        (newSchema, oldSchema) => {\n          const oldKey = instanceKey2;\n          instanceKey2 = {};\n          instanceScopes.set(instanceKey2, []);\n          provider = parseSchema(library, props.schema, props.memoKey);\n          render = createRenderFn(provider, data, instanceKey2);\n          if (newSchema === oldSchema) {\n            (instance?.proxy?.$forceUpdate)();\n          }\n          clean(props.schema, props.memoKey, oldKey);\n        },\n        { deep: true }\n      );\n    }\n    watchEffect(() => {\n      data = Object.assign(reactive(props.data ?? {}), {\n        slots: context.slots\n      });\n      context.slots;\n      render = createRenderFn(provider, data, instanceKey2);\n    });\n    function cleanUp() {\n      clean(props.schema, props.memoKey, instanceKey2);\n      if (data.node)\n        data.node.destroy();\n      data.slots = null;\n      data = null;\n      render = null;\n    }\n    onMounted(() => context.emit(\"mounted\"));\n    onUnmounted(cleanUp);\n    onSSRComplete(getCurrentInstance()?.appContext.app, cleanUp);\n    return () => render ? render() : null;\n  }\n});\nvar FormKitSchema_default = FormKitSchema;\nvar isServer3 = typeof window === \"undefined\";\nvar parentSymbol = Symbol(\"FormKitParent\");\nvar componentSymbol = Symbol(\"FormKitComponentCallback\");\nvar currentSchemaNode = null;\nvar getCurrentSchemaNode = () => currentSchemaNode;\nfunction FormKit(props, context) {\n  const node = useInput(props, context);\n  if (!node.props.definition)\n    error(600, node);\n  if (node.props.definition.component) {\n    return () => h(\n      node.props.definition?.component,\n      {\n        context: node.context\n      },\n      { ...context.slots }\n    );\n  }\n  const schema = ref([]);\n  let memoKey = node.props.definition.schemaMemoKey;\n  const generateSchema = () => {\n    const schemaDefinition = node.props?.definition?.schema;\n    if (!schemaDefinition)\n      error(601, node);\n    if (typeof schemaDefinition === \"function\") {\n      currentSchemaNode = node;\n      schema.value = schemaDefinition({ ...props.sectionsSchema || {} });\n      currentSchemaNode = null;\n      if (memoKey && props.sectionsSchema || \"memoKey\" in schemaDefinition && typeof schemaDefinition.memoKey === \"string\") {\n        memoKey = (memoKey ?? schemaDefinition?.memoKey) + JSON.stringify(props.sectionsSchema);\n      }\n    } else {\n      schema.value = schemaDefinition;\n    }\n  };\n  generateSchema();\n  if (!isServer3) {\n    node.on(\"schema\", () => {\n      memoKey += \"♻️\";\n      generateSchema();\n    });\n  }\n  context.emit(\"node\", node);\n  const definitionLibrary = node.props.definition.library;\n  const library = {\n    FormKit: markRaw(formkitComponent),\n    ...definitionLibrary\n  };\n  function didMount() {\n    node.emit(\"mounted\");\n  }\n  context.expose({ node });\n  return () => h(\n    FormKitSchema,\n    {\n      schema: schema.value,\n      data: node.context,\n      onMounted: didMount,\n      library,\n      memoKey\n    },\n    { ...context.slots }\n  );\n}\nvar formkitComponent = /* @__PURE__ */ defineComponent(\n  FormKit,\n  {\n    props: runtimeProps,\n    inheritAttrs: false\n  }\n);\nvar FormKit_default = formkitComponent;\nvar rootSymbol = Symbol();\nvar FormKitRoot = /* @__PURE__ */ defineComponent((_p, context) => {\n  const boundary = ref(null);\n  const showBody = ref(false);\n  const shadowRoot = ref(void 0);\n  const stopWatch = watch(boundary, (el) => {\n    let parent = el;\n    let root = null;\n    while (parent = parent?.parentNode) {\n      root = parent;\n      if (root instanceof ShadowRoot || root instanceof Document) {\n        foundRoot(root);\n        break;\n      }\n    }\n    stopWatch();\n    showBody.value = true;\n  });\n  provide(rootSymbol, shadowRoot);\n  function foundRoot(root) {\n    shadowRoot.value = root;\n  }\n  return () => showBody.value && context.slots.default ? context.slots.default() : h(\"template\", { ref: boundary });\n});\nfunction createPlugin(app, options) {\n  app.component(options.alias || \"FormKit\", FormKit_default).component(options.schemaAlias || \"FormKitSchema\", FormKitSchema_default);\n  return {\n    get: getNode,\n    setLocale: (locale) => {\n      if (options.config?.rootConfig) {\n        options.config.rootConfig.locale = locale;\n      }\n    },\n    clearErrors,\n    setErrors,\n    submit: submitForm,\n    reset\n  };\n}\nvar optionsSymbol = Symbol.for(\"FormKitOptions\");\nvar configSymbol = Symbol.for(\"FormKitConfig\");\nvar plugin = {\n  install(app, _options) {\n    const options = Object.assign(\n      {\n        alias: \"FormKit\",\n        schemaAlias: \"FormKitSchema\"\n      },\n      typeof _options === \"function\" ? _options() : _options\n    );\n    const rootConfig = createConfig(options.config || {});\n    options.config = { rootConfig };\n    app.config.globalProperties.$formkit = createPlugin(app, options);\n    app.provide(optionsSymbol, options);\n    app.provide(configSymbol, rootConfig);\n    if (typeof window !== \"undefined\") {\n      globalThis.__FORMKIT_CONFIGS__ = (globalThis.__FORMKIT_CONFIGS__ || []).concat([rootConfig]);\n    }\n  }\n};\n\n// packages/vue/src/composables/useInput.ts\nvar isBrowser = typeof window !== \"undefined\";\nvar pseudoProps = [\n  // Boolean props\n  \"ignore\",\n  \"disabled\",\n  \"preserve\",\n  // String props\n  \"help\",\n  \"label\",\n  /^preserve(-e|E)rrors/,\n  /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/,\n  /^[a-zA-Z-]+(?:-class|Class)$/,\n  \"prefixIcon\",\n  \"suffixIcon\",\n  /^[a-zA-Z-]+(?:-icon|Icon)$/\n];\nvar boolProps = [\"disabled\", \"ignore\", \"preserve\"];\nfunction classesToNodeProps(node, props) {\n  if (props.classes) {\n    Object.keys(props.classes).forEach(\n      (key) => {\n        if (typeof key === \"string\") {\n          node.props[`_${key}Class`] = props.classes[key];\n          if (isObject(props.classes[key]) && key === \"inner\")\n            Object.values(props.classes[key]);\n        }\n      }\n    );\n  }\n}\nfunction onlyListeners(props) {\n  if (!props)\n    return {};\n  const knownListeners = [\"Submit\", \"SubmitRaw\", \"SubmitInvalid\"].reduce(\n    (listeners, listener) => {\n      const name = `on${listener}`;\n      if (name in props) {\n        if (typeof props[name] === \"function\") {\n          listeners[name] = props[name];\n        }\n      }\n      return listeners;\n    },\n    {}\n  );\n  return knownListeners;\n}\nfunction useInput(props, context, options = {}) {\n  const config = Object.assign({}, inject(optionsSymbol) || {}, options);\n  const __root = inject(rootSymbol, ref(isBrowser ? document : void 0));\n  const __cmpCallback = inject(componentSymbol, () => {\n  });\n  const instance = getCurrentInstance();\n  const listeners = onlyListeners(instance?.vnode.props);\n  const isVModeled = [\"modelValue\", \"model-value\"].some(\n    (prop) => prop in (instance?.vnode.props ?? {})\n  );\n  let isMounted = false;\n  onMounted(() => {\n    isMounted = true;\n  });\n  const value = props.modelValue !== void 0 ? props.modelValue : cloneAny(context.attrs.value);\n  function createInitialProps() {\n    const initialProps2 = {\n      ...nodeProps(props),\n      ...listeners,\n      type: props.type ?? \"text\",\n      __root: __root.value,\n      __slots: context.slots\n    };\n    const attrs = except(nodeProps(context.attrs), pseudoProps);\n    if (!attrs.key)\n      attrs.key = token();\n    initialProps2.attrs = attrs;\n    const propValues = only(nodeProps(context.attrs), pseudoProps);\n    for (const propName in propValues) {\n      if (boolProps.includes(propName) && propValues[propName] === \"\") {\n        propValues[propName] = true;\n      }\n      initialProps2[camel(propName)] = propValues[propName];\n    }\n    const classesProps = { props: {} };\n    classesToNodeProps(classesProps, props);\n    Object.assign(initialProps2, classesProps.props);\n    if (typeof initialProps2.type !== \"string\") {\n      initialProps2.definition = initialProps2.type;\n      delete initialProps2.type;\n    }\n    return initialProps2;\n  }\n  const initialProps = createInitialProps();\n  const parent = initialProps.ignore ? null : props.parent || inject(parentSymbol, null);\n  const node = createNode(\n    extend(\n      config || {},\n      {\n        name: props.name || void 0,\n        value,\n        parent,\n        plugins: (config.plugins || []).concat(props.plugins ?? []),\n        config: props.config || {},\n        props: initialProps,\n        index: props.index,\n        sync: !!undefine(context.attrs.sync || context.attrs.dynamic)\n      },\n      false,\n      true\n    )\n  );\n  __cmpCallback(node);\n  if (!node.props.definition)\n    error(600, node);\n  const lateBoundProps = ref(\n    new Set(\n      Array.isArray(node.props.__propDefs) ? node.props.__propDefs : Object.keys(node.props.__propDefs ?? {})\n    )\n  );\n  node.on(\n    \"added-props\",\n    ({ payload: lateProps }) => {\n      const propNames = Array.isArray(lateProps) ? lateProps : Object.keys(lateProps ?? {});\n      propNames.forEach((newProp) => lateBoundProps.value.add(newProp));\n    }\n  );\n  const pseudoPropNames = computed(\n    () => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\n      if (typeof prop === \"string\") {\n        names.push(camel(prop));\n        names.push(kebab(prop));\n      } else {\n        names.push(prop);\n      }\n      return names;\n    }, [])\n  );\n  watchEffect(() => classesToNodeProps(node, props));\n  const passThrough = nodeProps(props);\n  for (const prop in passThrough) {\n    watch(\n      () => props[prop],\n      () => {\n        if (props[prop] !== void 0) {\n          node.props[prop] = props[prop];\n        }\n      }\n    );\n  }\n  watchEffect(() => {\n    node.props.__root = __root.value;\n  });\n  const attributeWatchers = /* @__PURE__ */ new Set();\n  const possibleProps = nodeProps(context.attrs);\n  watchEffect(() => {\n    watchAttributes(only(possibleProps, pseudoPropNames.value));\n  });\n  function watchAttributes(attrProps) {\n    attributeWatchers.forEach((stop) => {\n      stop();\n      attributeWatchers.delete(stop);\n    });\n    for (const prop in attrProps) {\n      const camelName = camel(prop);\n      attributeWatchers.add(\n        watch(\n          () => context.attrs[prop],\n          () => {\n            node.props[camelName] = context.attrs[prop];\n          }\n        )\n      );\n    }\n  }\n  watchEffect(() => {\n    const attrs = except(nodeProps(context.attrs), pseudoPropNames.value);\n    if (\"multiple\" in attrs)\n      attrs.multiple = undefine(attrs.multiple);\n    if (typeof attrs.onBlur === \"function\") {\n      attrs.onBlur = oncePerTick(attrs.onBlur);\n    }\n    node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);\n  });\n  watchEffect(() => {\n    const messages3 = (props.errors ?? []).map(\n      (error3) => createMessage({\n        key: slugify(error3),\n        type: \"error\",\n        value: error3,\n        meta: { source: \"prop\" }\n      })\n    );\n    node.store.apply(\n      messages3,\n      (message3) => message3.type === \"error\" && message3.meta.source === \"prop\"\n    );\n  });\n  if (node.type !== \"input\") {\n    const sourceKey = `${node.name}-prop`;\n    watchEffect(() => {\n      const inputErrors = props.inputErrors ?? {};\n      const keys = Object.keys(inputErrors);\n      if (!keys.length)\n        node.clearErrors(true, sourceKey);\n      const messages3 = keys.reduce((messages4, key) => {\n        let value2 = inputErrors[key];\n        if (typeof value2 === \"string\")\n          value2 = [value2];\n        if (Array.isArray(value2)) {\n          messages4[key] = value2.map(\n            (error3) => createMessage({\n              key: error3,\n              type: \"error\",\n              value: error3,\n              meta: { source: sourceKey }\n            })\n          );\n        }\n        return messages4;\n      }, {});\n      node.store.apply(\n        messages3,\n        (message3) => message3.type === \"error\" && message3.meta.source === sourceKey\n      );\n    });\n  }\n  watchEffect(() => Object.assign(node.config, props.config));\n  if (node.type !== \"input\") {\n    provide(parentSymbol, node);\n  }\n  let clonedValueBeforeVmodel = void 0;\n  node.on(\"modelUpdated\", () => {\n    context.emit(\"inputRaw\", node.context?.value, node);\n    if (isMounted) {\n      context.emit(\"input\", node.context?.value, node);\n    }\n    if (isVModeled && node.context) {\n      clonedValueBeforeVmodel = cloneAny(node.value);\n      context.emit(\"update:modelValue\", shallowClone(node.value));\n    }\n  });\n  if (isVModeled) {\n    watch(\n      toRef(props, \"modelValue\"),\n      (value2) => {\n        if (!eq(clonedValueBeforeVmodel, value2)) {\n          node.input(value2, false);\n        }\n      },\n      { deep: true }\n    );\n    if (node.value !== value) {\n      node.emit(\"modelUpdated\");\n    }\n  }\n  onBeforeUnmount(() => node.destroy());\n  return node;\n}\nvar totalCreated = 1;\nfunction isComponent2(obj) {\n  return typeof obj === \"function\" && obj.length === 2 || typeof obj === \"object\" && !Array.isArray(obj) && !(\"$el\" in obj) && !(\"$cmp\" in obj) && !(\"if\" in obj);\n}\nfunction createInput(schemaOrComponent, definitionOptions = {}, sectionsSchema = {}) {\n  const definition3 = {\n    type: \"input\",\n    ...definitionOptions\n  };\n  let schema;\n  if (isComponent2(schemaOrComponent)) {\n    const cmpName = `SchemaComponent${totalCreated++}`;\n    schema = createSection(\"input\", () => ({\n      $cmp: cmpName,\n      props: {\n        context: \"$node.context\"\n      }\n    }));\n    definition3.library = { [cmpName]: markRaw(schemaOrComponent) };\n  } else if (typeof schemaOrComponent === \"function\") {\n    schema = schemaOrComponent;\n  } else {\n    schema = createSection(\"input\", () => cloneAny(schemaOrComponent));\n  }\n  definition3.schema = useSchema(schema || \"Schema undefined\", sectionsSchema);\n  if (!definition3.schemaMemoKey) {\n    definition3.schemaMemoKey = `${Math.random()}`;\n  }\n  return definition3;\n}\n\n// packages/vue/src/composables/defineFormKitConfig.ts\nfunction defineFormKitConfig(config) {\n  return () => typeof config === \"function\" ? config() : config;\n}\nvar inputList = {};\nvar schemas = {};\nvar classes = {\n  container: `\n    formkit-kitchen-sink \n    p-8\n  `,\n  tabs: `\n    formkit-tabs \n    mt-4 \n    mr-[min(350px,25vw)]\n  `,\n  tab: `\n    formkit-kitchen-sink-tab\n    inline-block\n    mb-4\n    -mr-px\n    cursor-pointer\n    px-4\n    py-2\n    border\n    border-neutral-200\n    text-neutral-800\n    data-[active]:bg-neutral-800\n    data-[active]:border-neutral-800\n    data-[active]:text-neutral-50\n    hover:bg-neutral-100\n    hover:text-neutral-900\n    dark:border-neutral-700\n    dark:text-neutral-50\n    dark:data-[active]:bg-neutral-100\n    dark:data-[active]:border-neutral-100\n    dark:data-[active]:text-neutral-800\n    dark:hover:bg-neutral-800\n    dark:hover:text-neutral-50\n  `,\n  filterContainer: `\n    formkit-filter-container\n    grid\n    grid-cols-[repeat(auto-fit,300px)]\n    mr-[min(350px,25vw)]\n    -mt-4\n    mb-8\n    px-4\n    pt-8\n    pb-4\n    border\n    relative\n    -translate-y-px\n    max-w-[1000px]\n    border-neutral-200\n    dark:border-neutral-700\n  `,\n  filterGroup: `\n    formkit-filter-group\n    mr-8\n    mb-8\n    [&_legend]:text-lg\n    [&_ul]:columns-2\n    [&_ul>li:first-child]:[column-span:all]\n    [&_ul>li:first-child]:mt-2\n    [&_ul>li:first-child]:mb-2\n    [&_ul>li:first-child]:pb-2\n    [&_ul>li:first-child]:border-b\n    [&_ul>li:first-child]:border-neutral-200\n    dark:[&_ul>li:first-child]:border-neutral-700\n  `,\n  formContainer: `\n    formkit-form-container\n    w-full\n    bg-white\n    rounded\n    border\n    border-neutral-100\n    shadow-lg\n    max-w-[800px]\n    p-[min(5vw,5rem)]\n    dark:bg-neutral-900\n    dark:border-neutral-800\n    dark:shadow-3xl\n    [&_form>h1]:text-2xl\n    [&_form>h1]:mb-4\n    [&_form>h1]:font-bold\n    [&_form>h1+p]:text-base\n    [&_form>h1+p]:mb-4\n    [&_form>h1+p]:-mt-2\n    [&_form_.double]:flex\n    [&_form_.double>*]:w-1/2\n    [&_form_.double>*:first-child]:mr-2\n    [&_form_.triple]:flex\n    [&_form_.triple>*]:w-1/3\n    [&_form_.triple>*:first-child]:mr-2\n    [&_form_.triple>*:last-child]:ml-2\n  `,\n  inputs: `formkit-inputs`,\n  specimen: `\n    formkit-specimen \n    flex \n    flex-col \n    p-2 \n    max-w-[75vw]\n  `,\n  inputSection: `\n    group/section\n    formkit-input-section \n    mr-[min(325px,25vw)]\n  `,\n  specimenGroup: `\n    formkit-specimen-group\n    grid\n    mb-16\n    grid-cols-[repeat(auto-fit,400px)]\n    group-data-[type=\"transferlist\"]/section:grid-cols-[repeat(auto-fit,650px)]\n    group-data-[type=\"multi-step\"]/section:grid-cols-[repeat(auto-fit,550px)]\n  `,\n  inputType: `\n    formkit-input-type\n    block\n    font-bold\n    text-neutral-900\n    border-b\n    border-neutral-100\n    text-3xl\n    mb-8\n    pb-2\n    capitalize\n    dark:border-neutral-800 \n    dark:text-neutral-50\n  `\n};\nasync function fetchInputList() {\n  const response = await fetch(\n    \"https://raw.githubusercontent.com/formkit/input-schemas/master/index.json\"\n  );\n  const json = await response.json();\n  return json;\n}\nasync function fetchInputSchema(input) {\n  try {\n    const response = await fetch(\n      `https://raw.githubusercontent.com/formkit/input-schemas/master/schemas/${input}.json`\n    );\n    const json = await response.json();\n    return json;\n  } catch (error3) {\n    console.error(error3);\n  }\n}\nvar FormKitKitchenSink = /* @__PURE__ */ defineComponent({\n  name: \"FormKitKitchenSink\",\n  props: {\n    schemas: {\n      type: Array,\n      required: false\n    },\n    pro: {\n      type: Boolean,\n      default: true\n    },\n    addons: {\n      type: Boolean,\n      default: true\n    },\n    forms: {\n      type: Boolean,\n      default: true\n    },\n    navigation: {\n      type: Boolean,\n      default: true\n    }\n  },\n  async setup(props) {\n    onMounted(() => {\n      const filterNode = getNode(\"filter-checkboxes\");\n      data.filters = computed(() => {\n        if (!filterNode?.context)\n          return [];\n        const filters = filterNode.context.value;\n        const filterValues = [];\n        Object.keys(filters).forEach((key) => {\n          filterValues.push(...filters[key]);\n        });\n        return filterValues;\n      });\n    });\n    inputList = Object.keys(inputList).length ? inputList : await fetchInputList();\n    const promises = [];\n    const activeTab = ref(\"\");\n    const inputCheckboxes = computed(() => {\n      const inputGroups = {\n        core: { label: \"Inputs\", name: \"core\", inputs: inputList.core }\n      };\n      if (props.pro) {\n        inputGroups.pro = {\n          label: \"Pro Inputs\",\n          name: \"pro\",\n          inputs: inputList.pro\n        };\n      }\n      if (props.addons) {\n        inputGroups.addons = {\n          label: \"Add-ons\",\n          name: \"addons\",\n          inputs: inputList.addons\n        };\n      }\n      return inputGroups;\n    });\n    if (!props.schemas) {\n      const coreInputPromises = inputList.core.map(async (schema) => {\n        const response = await fetchInputSchema(schema);\n        schemas[schema] = response;\n      });\n      promises.push(...coreInputPromises);\n      if (props.forms) {\n        const formsPromises = inputList.forms.map(async (schema) => {\n          const schemaName = `form/${schema}`;\n          const response = await fetchInputSchema(schemaName);\n          schemas[schemaName] = response;\n        });\n        promises.push(...formsPromises);\n      }\n      if (props.pro) {\n        const proInputPromises = inputList.pro.map(async (schema) => {\n          const response = await fetchInputSchema(schema);\n          schemas[schema] = response;\n        });\n        promises.push(...proInputPromises);\n      }\n      if (props.addons) {\n        const addonPromises = inputList.addons.map(async (schema) => {\n          const response = await fetchInputSchema(schema);\n          schemas[schema] = response;\n        });\n        promises.push(...addonPromises);\n      }\n    } else {\n      const schemaPromises = props.schemas.map(async (schema) => {\n        const response = await fetchInputSchema(`${schema}`);\n        schemas[`${schema}`] = response;\n      });\n      promises.push(...schemaPromises);\n    }\n    const selectAll = (node) => {\n      let previousValue = [];\n      let skip = false;\n      if (node.props.type !== \"checkbox\")\n        return;\n      node.on(\"created\", () => {\n        const currentValue = node.value;\n        if (Array.isArray(currentValue) && currentValue.length === 1 && currentValue[0] === \"all\") {\n          node.input(\n            node.props.options.map((option) => {\n              if (typeof option !== \"string\")\n                return option.value;\n              return option;\n            })\n          );\n        }\n        previousValue = Array.isArray(node.value) ? node.value : [];\n      });\n      node.on(\"commit\", ({ payload }) => {\n        if (skip) {\n          skip = false;\n          return;\n        }\n        if (!Array.isArray(payload))\n          return;\n        const previousValueHadAll = previousValue.includes(\"all\");\n        const currentValueHasAll = payload.includes(\"all\");\n        if (!previousValueHadAll && currentValueHasAll) {\n          const computedOptions = node.props.options.map(\n            (option) => {\n              if (typeof option !== \"string\")\n                return option.value;\n              return option;\n            }\n          );\n          node.input(computedOptions);\n          previousValue = computedOptions;\n          return;\n        }\n        if (previousValueHadAll && !currentValueHasAll) {\n          node.input([]);\n          previousValue = [];\n          return;\n        }\n        const valueMinusAll = payload.filter((value) => value !== \"all\");\n        if (valueMinusAll.length < node.props.options.length - 1 && currentValueHasAll) {\n          node.input(valueMinusAll);\n          previousValue = valueMinusAll;\n          skip = true;\n          return;\n        }\n        if (valueMinusAll.length === node.props.options.length - 1 && !currentValueHasAll) {\n          const computedOptions = node.props.options.map(\n            (option) => {\n              if (typeof option !== \"string\")\n                return option.value;\n              return option;\n            }\n          );\n          node.input(computedOptions);\n          previousValue = Array.isArray(node.value) ? node.value : [];\n          return;\n        }\n      });\n    };\n    const data = reactive({\n      twClasses: classes,\n      basicOptions: Array.from({ length: 15 }, (_, i) => `Option ${i + 1}`),\n      asyncLoader: async () => {\n        return await new Promise(() => {\n        });\n      },\n      paginatedLoader: async ({\n        page,\n        hasNextPage\n      }) => {\n        const base = (page - 1) * 10;\n        hasNextPage();\n        return Array.from({ length: 10 }, (_, i) => `Option ${base + i + 1}`);\n      },\n      formSubmitHandler: async (data2) => {\n        await new Promise((resolve) => setTimeout(resolve, 1e3));\n        alert(\"Form submitted (fake) — check console for data object\");\n        console.log(\"Form data:\", data2);\n      },\n      includes: (array, value) => {\n        if (!Array.isArray(array))\n          return false;\n        return array.includes(value);\n      },\n      checkboxPlugins: [selectAll],\n      filters: []\n    });\n    await Promise.all(promises);\n    const inputKeys = Object.keys(schemas);\n    const formNames = inputKeys.map((key) => {\n      if (key.startsWith(\"form/\")) {\n        switch (key) {\n          case \"form/tshirt\":\n            return {\n              id: key,\n              name: \"Order Form\"\n            };\n          default:\n            const name = key.replace(\"form/\", \"\");\n            return {\n              id: key,\n              name: name.charAt(0).toUpperCase() + name.slice(1) + \" Form\"\n            };\n        }\n      }\n      return {\n        id: key,\n        name: \"\"\n      };\n    });\n    const filteredFormNames = formNames.filter((form) => form.name !== \"\");\n    const forms = inputKeys.filter((schema) => {\n      return schema.startsWith(\"form/\");\n    });\n    const inputs = inputKeys.filter(\n      (schema) => !schema.startsWith(\"form/\")\n    );\n    const tabs = [];\n    if (inputs.length) {\n      tabs.push({\n        id: \"kitchen-sink\",\n        name: \"Kitchen Sink\"\n      });\n    }\n    if (forms.length) {\n      tabs.push(...filteredFormNames.sort((a, b) => a.name > b.name ? 1 : -1));\n    }\n    if (tabs.length) {\n      activeTab.value = tabs[0].id;\n    }\n    const kitchenSinkRenders = computed(() => {\n      inputs.sort();\n      const schemaDefinitions = inputs.reduce(\n        (schemaDefinitions2, inputName) => {\n          const schemaDefinition = schemas[inputName];\n          schemaDefinitions2.push({\n            $el: \"div\",\n            if: '$includes($filters, \"' + inputName + '\")',\n            attrs: {\n              key: inputName,\n              class: \"$twClasses.inputSection\",\n              \"data-type\": inputName\n            },\n            children: [\n              {\n                $el: \"h2\",\n                attrs: {\n                  class: \"$twClasses.inputType\"\n                },\n                children: inputName\n              },\n              {\n                $el: \"div\",\n                attrs: {\n                  class: \"$twClasses.specimenGroup\"\n                },\n                children: [\n                  ...(Array.isArray(schemaDefinition) ? schemaDefinition : [schemaDefinition]).map((specimen) => {\n                    return {\n                      $el: \"div\",\n                      attrs: {\n                        class: \"$twClasses.specimen\"\n                      },\n                      children: [specimen]\n                    };\n                  })\n                ]\n              }\n            ]\n          });\n          return schemaDefinitions2;\n        },\n        []\n      );\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            return activeTab.value === \"kitchen-sink\" ? h(FormKitSchema, { schema: schemaDefinitions, data }) : null;\n          }\n        }\n      );\n    });\n    const formRenders = computed(() => {\n      return filteredFormNames.map((form) => {\n        const schemaDefinition = schemas[form.id];\n        return h(\n          \"div\",\n          {\n            key: form.id\n          },\n          activeTab.value === form.id ? [\n            h(\n              \"div\",\n              {\n                class: classes.formContainer\n              },\n              [\n                h(FormKitSchema, {\n                  schema: schemaDefinition[0],\n                  data\n                })\n              ]\n            )\n          ] : \"\"\n        );\n      }).filter((form) => form.children);\n    });\n    const tabBar = computed(() => {\n      return h(\n        \"div\",\n        {\n          key: \"tab-bar\",\n          class: classes.tabs\n        },\n        tabs.map((tab) => {\n          return h(\n            \"span\",\n            {\n              class: classes.tab,\n              key: tab.id,\n              \"data-tab\": tab.id,\n              \"data-active\": activeTab.value === tab.id || void 0,\n              onClick: () => {\n                activeTab.value = tab.id;\n              }\n            },\n            tab.name\n          );\n        })\n      );\n    });\n    const filterCheckboxes = computed(() => {\n      const createCheckboxSchema = (inputGroup) => {\n        return {\n          $el: \"div\",\n          attrs: {\n            class: \"$twClasses.filterGroup\"\n          },\n          children: [\n            {\n              $formkit: \"checkbox\",\n              name: inputGroup.name,\n              label: inputGroup.label,\n              plugins: \"$checkboxPlugins\",\n              value: [\"all\"],\n              options: [\n                {\n                  label: \"All\",\n                  value: \"all\"\n                },\n                ...Array.isArray(inputGroup.inputs) ? inputGroup.inputs : []\n              ]\n            }\n          ]\n        };\n      };\n      const filterSchema = h(FormKitSchema, {\n        key: \"filter-checkboxes\",\n        data,\n        schema: {\n          $formkit: \"group\",\n          id: \"filter-checkboxes\",\n          children: [\n            {\n              $el: \"div\",\n              attrs: {\n                class: \"$twClasses.filterContainer\"\n              },\n              children: Object.keys(inputCheckboxes.value).map((key) => {\n                const inputGroup = inputCheckboxes.value[key];\n                return createCheckboxSchema(inputGroup);\n              })\n            }\n          ]\n        }\n      });\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            if (!(tabs.find((tab) => tab.id === \"kitchen-sink\") && activeTab.value === \"kitchen-sink\")) {\n              return null;\n            }\n            return filterSchema;\n          }\n        }\n      );\n    });\n    return () => {\n      return h(\n        \"div\",\n        {\n          class: classes.container\n        },\n        [\n          tabs.length > 1 ? tabBar.value : void 0,\n          filterCheckboxes.value,\n          ...formRenders.value,\n          kitchenSinkRenders.value\n        ]\n      );\n    };\n  }\n});\nvar messages = createSection(\"messages\", () => ({\n  $el: \"ul\",\n  if: \"$fns.length($messages)\"\n}));\nvar message = createSection(\"message\", () => ({\n  $el: \"li\",\n  for: [\"message\", \"$messages\"],\n  attrs: {\n    key: \"$message.key\",\n    id: `$id + '-' + $message.key`,\n    \"data-message-type\": \"$message.type\"\n  }\n}));\nvar definition = messages(message(\"$message.value\"));\nvar FormKitMessages = /* @__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object,\n      required: false\n    },\n    sectionsSchema: {\n      type: Object,\n      default: {}\n    },\n    defaultPosition: {\n      type: [String, Boolean],\n      default: false\n    }\n  },\n  setup(props, context) {\n    const node = computed(() => {\n      return props.node || inject(parentSymbol, void 0);\n    });\n    watch(\n      node,\n      () => {\n        if (node.value?.context && !undefine(props.defaultPosition)) {\n          node.value.context.defaultMessagePlacement = false;\n        }\n      },\n      { immediate: true }\n    );\n    const schema = definition(props.sectionsSchema || {});\n    const data = computed(() => {\n      return {\n        messages: node.value?.context?.messages || {},\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {}\n      };\n    });\n    return () => node.value?.context ? h(FormKitSchema_default, { schema, data: data.value }, { ...context.slots }) : null;\n  }\n});\nfunction useConfig(config) {\n  const options = Object.assign(\n    {\n      alias: \"FormKit\",\n      schemaAlias: \"FormKitSchema\"\n    },\n    typeof config === \"function\" ? config() : config\n  );\n  const rootConfig = createConfig(options.config || {});\n  options.config = { rootConfig };\n  provide(optionsSymbol, options);\n  provide(configSymbol, rootConfig);\n  if (typeof window !== \"undefined\") {\n    globalThis.__FORMKIT_CONFIGS__ = (globalThis.__FORMKIT_CONFIGS__ || []).concat([rootConfig]);\n  }\n}\nvar FormKitProvider = /* @__PURE__ */ defineComponent(\n  function FormKitProvider2(props, { slots, attrs }) {\n    const options = {};\n    if (props.config) {\n      useConfig(props.config);\n    }\n    return () => slots.default ? slots.default(options).map((vnode) => {\n      return h(vnode, {\n        ...attrs,\n        ...vnode.props\n      });\n    }) : null;\n  },\n  { props: [\"config\"], name: \"FormKitProvider\", inheritAttrs: false }\n);\nvar FormKitConfigLoader = /* @__PURE__ */ defineComponent(\n  async function FormKitConfigLoader2(props, context) {\n    let config = {};\n    if (props.configFile) {\n      const configFile = await __vitePreload(() => import(\n        \"/Users/sebastianwessel/projekte/voyage/formkit.config.ts\"),__VITE_IS_MODERN__?\"__VITE_PRELOAD__\":void 0,import.meta.url);\n      config = \"default\" in configFile ? configFile.default : configFile;\n    }\n    if (typeof config === \"function\") {\n      config = config();\n    }\n    const useDefaultConfig = props.defaultConfig ?? true;\n    if (useDefaultConfig) {\n      const { defaultConfig: defaultConfig2 } = await Promise.resolve().then(() => (init_defaultConfig(), defaultConfig_exports));\n      config = /* @__PURE__ */ defaultConfig2(config);\n    }\n    return () => h(FormKitProvider, { ...context.attrs, config }, context.slots);\n  },\n  {\n    props: [\"defaultConfig\", \"configFile\"],\n    inheritAttrs: false\n  }\n);\nvar FormKitLazyProvider = /* @__PURE__ */ defineComponent(\n  function FormKitLazyProvider2(props, context) {\n    const config = inject(optionsSymbol, null);\n    const passthru = (vnode) => {\n      return h(vnode, {\n        ...context.attrs,\n        ...vnode.props\n      });\n    };\n    if (config) {\n      return () => context.slots?.default ? context.slots.default().map(passthru) : null;\n    }\n    const instance = getCurrentInstance();\n    if (instance.suspense) {\n      return () => h(FormKitConfigLoader, props, {\n        default: () => context.slots?.default ? context.slots.default().map(passthru) : null\n      });\n    }\n    return () => h(Suspense, null, {\n      ...context.slots,\n      default: () => h(FormKitConfigLoader, { ...context.attrs, ...props }, context.slots)\n    });\n  },\n  {\n    props: [\"defaultConfig\", \"configFile\"],\n    inheritAttrs: false\n  }\n);\nvar summary = createSection(\"summary\", () => ({\n  $el: \"div\",\n  attrs: {\n    \"aria-live\": \"polite\"\n  }\n}));\nvar summaryInner = createSection(\"summaryInner\", () => ({\n  $el: \"div\",\n  if: \"$summaries.length && $showSummaries\"\n}));\nvar messages2 = createSection(\"messages\", () => ({\n  $el: \"ul\",\n  if: \"$summaries.length && $showSummaries\"\n}));\nvar message2 = createSection(\"message\", () => ({\n  $el: \"li\",\n  for: [\"summary\", \"$summaries\"],\n  attrs: {\n    key: \"$summary.key\",\n    \"data-message-type\": \"$summary.type\"\n  }\n}));\nvar summaryHeader = createSection(\"summaryHeader\", () => ({\n  $el: \"h2\",\n  attrs: {\n    id: \"$id\"\n  }\n}));\nvar messageLink = createSection(\"messageLink\", () => ({\n  $el: \"a\",\n  attrs: {\n    id: \"$summary.key\",\n    href: '$: \"#\" + $summary.id',\n    onClick: \"$jumpLink\"\n  }\n}));\nvar definition2 = summary(\n  summaryInner(\n    summaryHeader(\"$summaryHeader\"),\n    messages2(message2(messageLink(\"$summary.message\")))\n  )\n);\nvar FormKitSummary = /* @__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object,\n      required: false\n    },\n    forceShow: {\n      type: Boolean,\n      default: false\n    },\n    sectionsSchema: {\n      type: Object,\n      default: {}\n    }\n  },\n  emits: {\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    show: (_summaries) => true\n  },\n  setup(props, context) {\n    const id = `summary-${token()}`;\n    const node = computed(() => {\n      return props.node || inject(parentSymbol, void 0);\n    });\n    if (!node)\n      throw new Error(\n        \"FormKitSummary must have a FormKit parent or use the node prop.\"\n      );\n    const summaryContexts = ref([]);\n    const showSummaries = ref(false);\n    const summaries = computed(() => {\n      const summarizedMessages = [];\n      summaryContexts.value.forEach((context2) => {\n        for (const idx in context2.messages) {\n          const message3 = context2.messages[idx];\n          if (typeof message3.value !== \"string\")\n            continue;\n          summarizedMessages.push({\n            message: message3.value,\n            id: context2.id,\n            key: `${context2.id}-${message3.key}`,\n            type: message3.type\n          });\n        }\n      });\n      return summarizedMessages;\n    });\n    const addContexts = () => {\n      summaryContexts.value = [];\n      node.value?.walk(\n        (child) => child.context && summaryContexts.value.push(child.context)\n      );\n    };\n    node.value?.on(\"submit-raw\", async () => {\n      addContexts();\n      if (summaries.value.length === 0)\n        return;\n      context.emit(\"show\", summaries.value);\n      showSummaries.value = true;\n      await nextTick();\n      if (typeof window !== \"undefined\") {\n        document.getElementById(id)?.scrollIntoView({ behavior: \"smooth\" });\n        if (summaries.value[0]) {\n          document.getElementById(summaries.value[0].key)?.focus();\n        }\n      }\n    });\n    node.value?.on(\"child\", addContexts);\n    function jumpLink(e) {\n      if (e.target instanceof HTMLAnchorElement) {\n        e.preventDefault();\n        const id2 = e.target.getAttribute(\"href\")?.substring(1);\n        if (id2) {\n          document.getElementById(id2)?.scrollIntoView({ behavior: \"smooth\" });\n          document.getElementById(id2)?.focus();\n        }\n      }\n    }\n    localize(\"summaryHeader\", \"There were errors in your form.\")(node.value);\n    const schema = definition2(props.sectionsSchema || {});\n    const data = computed(() => {\n      return {\n        id,\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {},\n        summaries: summaries.value,\n        showSummaries: props.forceShow || showSummaries.value,\n        summaryHeader: node.value?.context?.ui?.summaryHeader?.value || \"\",\n        jumpLink\n      };\n    });\n    return () => node.value?.context ? h(FormKitSchema_default, { schema, data: data.value }, { ...context.slots }) : null;\n  }\n});\n\n// packages/vue/src/index.ts\ninit_defaultConfig();\ninit_bindings();\nvar FormKitIcon = /* @__PURE__ */ defineComponent({\n  name: \"FormKitIcon\",\n  props: {\n    icon: {\n      type: String,\n      default: \"\"\n    },\n    iconLoader: {\n      type: Function,\n      default: null\n    },\n    iconLoaderUrl: {\n      type: Function,\n      default: null\n    }\n  },\n  setup(props) {\n    const icon = ref(void 0);\n    const config = inject(optionsSymbol, {});\n    const parent = inject(parentSymbol, null);\n    let iconHandler = void 0;\n    function loadIcon() {\n      if (!iconHandler || typeof iconHandler !== \"function\")\n        return;\n      const iconOrPromise = iconHandler(props.icon);\n      if (iconOrPromise instanceof Promise) {\n        iconOrPromise.then((iconValue) => {\n          icon.value = iconValue;\n        });\n      } else {\n        icon.value = iconOrPromise;\n      }\n    }\n    if (props.iconLoader && typeof props.iconLoader === \"function\") {\n      iconHandler = createIconHandler(props.iconLoader);\n    } else if (parent && parent.props?.iconLoader) {\n      iconHandler = createIconHandler(parent.props.iconLoader);\n    } else if (props.iconLoaderUrl && typeof props.iconLoaderUrl === \"function\") {\n      iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl);\n    } else {\n      const iconPlugin = config?.plugins?.find((plugin2) => {\n        return typeof plugin2.iconHandler === \"function\";\n      });\n      if (iconPlugin) {\n        iconHandler = iconPlugin.iconHandler;\n      }\n    }\n    watch(\n      () => props.icon,\n      () => {\n        loadIcon();\n      },\n      { immediate: true }\n    );\n    return () => {\n      if (props.icon && icon.value) {\n        return h(\"span\", {\n          class: \"formkit-icon\",\n          innerHTML: icon.value\n        });\n      }\n      return null;\n    };\n  }\n});\n\nexport { FormKit_default as FormKit, FormKitIcon, FormKitKitchenSink, FormKitLazyProvider, FormKitMessages, FormKitProvider, FormKitRoot, FormKitSchema, FormKitSummary, bindings_default as bindings, componentSymbol, configSymbol, createInput, defaultConfig, defineFormKitConfig, getCurrentSchemaNode, onSSRComplete, optionsSymbol, parentSymbol, plugin, rootSymbol, ssrComplete, useConfig, useInput };\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map",
      "start": 1709718915855,
      "end": 1709718915856,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:reporter",
      "start": 1709718915856,
      "end": 1709718915856,
      "order": "normal"
    }
  ]
}
