{
  "resolvedId": "/Users/sebastianwessel/projekte/voyage/node_modules/@formkit/validation/dist/index.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { createMessage } from '@formkit/core';\nimport { createObserver, removeListeners, isKilled, applyListeners, diffDeps } from '@formkit/observer';\nimport { cloneAny, token, eq, empty, clone, has } from '@formkit/utils';\n\n// packages/validation/src/validation.ts\nvar validatingMessage = createMessage({\n  type: \"state\",\n  blocking: true,\n  visible: false,\n  value: true,\n  key: \"validating\"\n});\nfunction createValidationPlugin(baseRules = {}) {\n  return function validationPlugin(node) {\n    let propRules = cloneAny(node.props.validationRules || {});\n    let availableRules = { ...baseRules, ...propRules };\n    let observedNode = createObserver(node);\n    const state = { input: token(), rerun: null, isPassing: true };\n    let validation = cloneAny(node.props.validation);\n    node.on(\"prop:validation\", ({ payload }) => reboot(payload, propRules));\n    node.on(\n      \"prop:validationRules\",\n      ({ payload }) => reboot(validation, payload)\n    );\n    function reboot(newValidation, newRules) {\n      if (eq(Object.keys(propRules || {}), Object.keys(newRules || {})) && eq(validation, newValidation))\n        return;\n      propRules = cloneAny(newRules);\n      validation = cloneAny(newValidation);\n      availableRules = { ...baseRules, ...propRules };\n      removeListeners(observedNode.receipts);\n      node.props.parsedRules?.forEach((validation2) => {\n        validation2.messageObserver = validation2.messageObserver?.kill();\n      });\n      node.store.filter(() => false, \"validation\");\n      node.props.parsedRules = parseRules(newValidation, availableRules);\n      observedNode.kill();\n      observedNode = createObserver(node);\n      validate(observedNode, node.props.parsedRules, state);\n    }\n    node.props.parsedRules = parseRules(validation, availableRules);\n    validate(observedNode, node.props.parsedRules, state);\n  };\n}\nfunction validate(node, validations, state) {\n  if (isKilled(node))\n    return;\n  state.input = token();\n  state.isPassing = true;\n  node.store.filter((message) => !message.meta.removeImmediately, \"validation\");\n  validations.forEach(\n    (validation) => validation.debounce && clearTimeout(validation.timer)\n  );\n  if (validations.length) {\n    node.store.set(validatingMessage);\n    run(0, validations, node, state, false, () => {\n      node.store.remove(validatingMessage.key);\n    });\n  }\n}\nfunction run(current, validations, node, state, removeImmediately, complete) {\n  const validation = validations[current];\n  if (!validation)\n    return complete();\n  const currentRun = state.input;\n  validation.state = null;\n  function next(async, result) {\n    state.isPassing = state.isPassing && !!result;\n    validation.queued = false;\n    const newDeps = node.stopObserve();\n    applyListeners(\n      node,\n      diffDeps(validation.deps, newDeps),\n      function revalidate() {\n        try {\n          node.store.set(validatingMessage);\n        } catch (e) {\n        }\n        validation.queued = true;\n        if (state.rerun)\n          clearTimeout(state.rerun);\n        state.rerun = setTimeout(\n          validate,\n          0,\n          node,\n          validations,\n          state\n        );\n      },\n      \"unshift\"\n      // We want these listeners to run before other events are emitted so the 'state.validating' will be reliable.\n    );\n    validation.deps = newDeps;\n    if (state.input === currentRun) {\n      validation.state = result;\n      if (result === false) {\n        createFailedMessage(node, validation, removeImmediately || async);\n      } else {\n        removeMessage(node, validation);\n      }\n      if (validations.length > current + 1) {\n        run(\n          current + 1,\n          validations,\n          node,\n          state,\n          removeImmediately || async,\n          complete\n        );\n      } else {\n        complete();\n      }\n    }\n  }\n  if ((!empty(node.value) || !validation.skipEmpty) && (state.isPassing || validation.force)) {\n    if (validation.queued) {\n      runRule(validation, node, (result) => {\n        result instanceof Promise ? result.then((r) => next(true, r)) : next(false, result);\n      });\n    } else {\n      run(current + 1, validations, node, state, removeImmediately, complete);\n    }\n  } else {\n    if (empty(node.value) && validation.skipEmpty && state.isPassing) {\n      node.observe();\n      node.value;\n      next(false, state.isPassing);\n    } else {\n      next(false, null);\n    }\n  }\n}\nfunction runRule(validation, node, after) {\n  if (validation.debounce) {\n    validation.timer = setTimeout(() => {\n      node.observe();\n      after(validation.rule(node, ...validation.args));\n    }, validation.debounce);\n  } else {\n    node.observe();\n    after(validation.rule(node, ...validation.args));\n  }\n}\nfunction removeMessage(node, validation) {\n  const key = `rule_${validation.name}`;\n  if (validation.messageObserver) {\n    validation.messageObserver = validation.messageObserver.kill();\n  }\n  if (has(node.store, key)) {\n    node.store.remove(key);\n  }\n}\nfunction createFailedMessage(node, validation, removeImmediately) {\n  if (isKilled(node))\n    return;\n  if (!validation.messageObserver) {\n    validation.messageObserver = createObserver(node._node);\n  }\n  validation.messageObserver.watch(\n    (node2) => {\n      const i18nArgs = createI18nArgs(\n        node2,\n        validation\n      );\n      return i18nArgs;\n    },\n    (i18nArgs) => {\n      const customMessage = createCustomMessage(node, validation, i18nArgs);\n      const message = createMessage({\n        blocking: validation.blocking,\n        key: `rule_${validation.name}`,\n        meta: {\n          /**\n           * Use this key instead of the message root key to produce i18n validation\n           * messages.\n           */\n          messageKey: validation.name,\n          /**\n           * For messages that were created *by or after* a debounced or async\n           * validation rule â€” we make note of it so we can immediately remove them\n           * as soon as the next commit happens.\n           */\n          removeImmediately,\n          /**\n           * Determines if this message should be passed to localization.\n           */\n          localize: !customMessage,\n          /**\n           * The arguments that will be passed to the validation rules\n           */\n          i18nArgs\n        },\n        type: \"validation\",\n        value: customMessage || \"This field is not valid.\"\n      });\n      node.store.set(message);\n    }\n  );\n}\nfunction createCustomMessage(node, validation, i18nArgs) {\n  const customMessage = node.props.validationMessages && has(node.props.validationMessages, validation.name) ? node.props.validationMessages[validation.name] : void 0;\n  if (typeof customMessage === \"function\") {\n    return customMessage(...i18nArgs);\n  }\n  return customMessage;\n}\nfunction createI18nArgs(node, validation) {\n  return [\n    {\n      node,\n      name: createMessageName(node),\n      args: validation.args\n    }\n  ];\n}\nfunction createMessageName(node) {\n  if (typeof node.props.validationLabel === \"function\") {\n    return node.props.validationLabel(node);\n  }\n  return node.props.validationLabel || node.props.label || node.props.name || String(node.name);\n}\nvar hintPattern = \"(?:[\\\\*+?()0-9]+)\";\nvar rulePattern = \"[a-zA-Z][a-zA-Z0-9_]+\";\nvar ruleExtractor = new RegExp(\n  `^(${hintPattern}?${rulePattern})(?:\\\\:(.*)+)?$`,\n  \"i\"\n);\nvar hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, \"i\");\nvar debounceExtractor = /([\\*+?]+)?(\\(\\d+\\))([\\*+?]+)?/;\nvar hasDebounce = /\\(\\d+\\)/;\nvar defaultHints = {\n  blocking: true,\n  debounce: 0,\n  force: false,\n  skipEmpty: true,\n  name: \"\"\n};\nfunction parseRules(validation, rules) {\n  if (!validation)\n    return [];\n  const intents = typeof validation === \"string\" ? extractRules(validation) : clone(validation);\n  return intents.reduce((validations, args) => {\n    let rule = args.shift();\n    const hints = {};\n    if (typeof rule === \"string\") {\n      const [ruleName, parsedHints] = parseHints(rule);\n      if (has(rules, ruleName)) {\n        rule = rules[ruleName];\n        Object.assign(hints, parsedHints);\n      }\n    }\n    if (typeof rule === \"function\") {\n      validations.push({\n        rule,\n        args,\n        timer: 0,\n        state: null,\n        queued: true,\n        deps: /* @__PURE__ */ new Map(),\n        ...defaultHints,\n        ...fnHints(hints, rule)\n      });\n    }\n    return validations;\n  }, []);\n}\nfunction extractRules(validation) {\n  return validation.split(\"|\").reduce((rules, rule) => {\n    const parsedRule = parseRule(rule);\n    if (parsedRule) {\n      rules.push(parsedRule);\n    }\n    return rules;\n  }, []);\n}\nfunction parseRule(rule) {\n  const trimmed = rule.trim();\n  if (trimmed) {\n    const matches = trimmed.match(ruleExtractor);\n    if (matches && typeof matches[1] === \"string\") {\n      const ruleName = matches[1].trim();\n      const args = matches[2] && typeof matches[2] === \"string\" ? matches[2].split(\",\").map((s) => s.trim()) : [];\n      return [ruleName, ...args];\n    }\n  }\n  return false;\n}\nfunction parseHints(ruleName) {\n  const matches = ruleName.match(hintExtractor);\n  if (!matches) {\n    return [ruleName, { name: ruleName }];\n  }\n  const map = {\n    \"*\": { force: true },\n    \"+\": { skipEmpty: false },\n    \"?\": { blocking: false }\n  };\n  const [, hints, rule] = matches;\n  const hintGroups = hasDebounce.test(hints) ? hints.match(debounceExtractor) || [] : [, hints];\n  return [\n    rule,\n    [hintGroups[1], hintGroups[2], hintGroups[3]].reduce(\n      (hints2, group) => {\n        if (!group)\n          return hints2;\n        if (hasDebounce.test(group)) {\n          hints2.debounce = parseInt(group.substr(1, group.length - 1));\n        } else {\n          group.split(\"\").forEach(\n            (hint) => has(map, hint) && Object.assign(hints2, map[hint])\n          );\n        }\n        return hints2;\n      },\n      { name: rule }\n    )\n  ];\n}\nfunction fnHints(existingHints, rule) {\n  if (!existingHints.name) {\n    existingHints.name = rule.ruleName || rule.name;\n  }\n  return [\"skipEmpty\", \"force\", \"debounce\", \"blocking\"].reduce(\n    (hints, hint) => {\n      if (has(rule, hint) && !has(hints, hint)) {\n        Object.assign(hints, {\n          [hint]: rule[hint]\n        });\n      }\n      return hints;\n    },\n    existingHints\n  );\n}\nfunction getValidationMessages(node) {\n  const messages = /* @__PURE__ */ new Map();\n  const extract = (n) => {\n    const nodeMessages = [];\n    for (const key in n.store) {\n      const message = n.store[key];\n      if (message.type === \"validation\" && message.visible && typeof message.value === \"string\") {\n        nodeMessages.push(message);\n      }\n    }\n    if (nodeMessages.length) {\n      messages.set(n, nodeMessages);\n    }\n    return n;\n  };\n  extract(node).walk(extract);\n  return messages;\n}\n\nexport { createMessageName, createValidationPlugin, getValidationMessages };\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map",
      "start": 1709718916284,
      "end": 1709718916361,
      "sourcemaps": null
    },
    {
      "name": "unplugin-formkit",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "post"
    },
    {
      "name": "element-plus:transform",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1709718916361,
      "end": 1709718916361,
      "order": "normal"
    }
  ]
}
