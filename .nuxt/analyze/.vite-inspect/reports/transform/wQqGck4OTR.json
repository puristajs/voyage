{
  "resolvedId": "/Users/sebastianwessel/projekte/voyage/node_modules/@formkit/utils/dist/index.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "// packages/utils/src/index.ts\nvar isBrowser = typeof window !== \"undefined\";\nvar explicitKeys = [\n  \"__key\",\n  \"__init\",\n  \"__shim\",\n  \"__original\",\n  \"__index\",\n  \"__prevKey\"\n];\nfunction token() {\n  return Math.random().toString(36).substring(2, 15);\n}\nfunction setify(items) {\n  return items instanceof Set ? items : new Set(items);\n}\nfunction dedupe(arr1, arr2) {\n  const original = arr1 instanceof Set ? arr1 : new Set(arr1);\n  if (arr2)\n    arr2.forEach((item) => original.add(item));\n  return [...original];\n}\nfunction has(obj, property) {\n  return Object.prototype.hasOwnProperty.call(obj, property);\n}\nfunction eq(valA, valB, deep = true, explicit = [\"__key\"]) {\n  if (valA === valB)\n    return true;\n  if (typeof valB === \"object\" && typeof valA === \"object\") {\n    if (valA instanceof Map)\n      return false;\n    if (valA instanceof Set)\n      return false;\n    if (valA instanceof Date && valB instanceof Date)\n      return valA.getTime() === valB.getTime();\n    if (valA instanceof RegExp && valB instanceof RegExp)\n      return eqRegExp(valA, valB);\n    if (valA === null || valB === null)\n      return false;\n    if (Object.keys(valA).length !== Object.keys(valB).length)\n      return false;\n    for (const k of explicit) {\n      if ((k in valA || k in valB) && valA[k] !== valB[k])\n        return false;\n    }\n    for (const key in valA) {\n      if (!(key in valB))\n        return false;\n      if (valA[key] !== valB[key] && !deep)\n        return false;\n      if (deep && !eq(valA[key], valB[key], deep, explicit))\n        return false;\n    }\n    return true;\n  }\n  return false;\n}\nfunction eqRegExp(x, y) {\n  return x.source === y.source && x.flags.split(\"\").sort().join(\"\") === y.flags.split(\"\").sort().join(\"\");\n}\nfunction empty(value) {\n  const type = typeof value;\n  if (type === \"number\")\n    return false;\n  if (value === void 0)\n    return true;\n  if (type === \"string\") {\n    return value === \"\";\n  }\n  if (type === \"object\") {\n    if (value === null)\n      return true;\n    for (const _i in value)\n      return false;\n    if (value instanceof RegExp)\n      return false;\n    if (value instanceof Date)\n      return false;\n    return true;\n  }\n  return false;\n}\nfunction escapeExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction regexForFormat(format) {\n  const escaped = `^${escapeExp(format)}$`;\n  const formats = {\n    MM: \"(0[1-9]|1[012])\",\n    M: \"([1-9]|1[012])\",\n    DD: \"([012][0-9]|3[01])\",\n    D: \"([012]?[0-9]|3[01])\",\n    YYYY: \"\\\\d{4}\",\n    YY: \"\\\\d{2}\"\n  };\n  const tokens = Object.keys(formats);\n  return new RegExp(\n    tokens.reduce((regex, format2) => {\n      return regex.replace(format2, formats[format2]);\n    }, escaped)\n  );\n}\nfunction nodeType(type) {\n  const t = type.toLowerCase();\n  if (t === \"list\")\n    return \"list\";\n  if (t === \"group\")\n    return \"group\";\n  return \"input\";\n}\nfunction isRecord(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction isObject(o) {\n  return isRecord(o) || Array.isArray(o);\n}\nfunction isPojo(o) {\n  if (isRecord(o) === false)\n    return false;\n  if (o.__FKNode__ || o.__POJO__ === false)\n    return false;\n  const ctor = o.constructor;\n  if (ctor === void 0)\n    return true;\n  const prot = ctor.prototype;\n  if (isRecord(prot) === false)\n    return false;\n  if (prot.hasOwnProperty(\"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nvar extend = /* @__NO_SIDE_EFFECTS__ */ (original, additional, extendArrays = false, ignoreUndefined = false) => {\n  if (additional === null)\n    return null;\n  const merged = {};\n  if (typeof additional === \"string\")\n    return additional;\n  for (const key in original) {\n    if (has(additional, key) && (additional[key] !== void 0 || !ignoreUndefined)) {\n      if (extendArrays && Array.isArray(original[key]) && Array.isArray(additional[key])) {\n        merged[key] = original[key].concat(additional[key]);\n        continue;\n      }\n      if (additional[key] === void 0) {\n        continue;\n      }\n      if (isPojo(original[key]) && isPojo(additional[key])) {\n        merged[key] = /* @__PURE__ */ extend(\n          original[key],\n          additional[key],\n          extendArrays,\n          ignoreUndefined\n        );\n      } else {\n        merged[key] = additional[key];\n      }\n    } else {\n      merged[key] = original[key];\n    }\n  }\n  for (const key in additional) {\n    if (!has(merged, key) && additional[key] !== void 0) {\n      merged[key] = additional[key];\n    }\n  }\n  return merged;\n};\nfunction isQuotedString(str) {\n  if (str[0] !== '\"' && str[0] !== \"'\")\n    return false;\n  if (str[0] !== str[str.length - 1])\n    return false;\n  const quoteType = str[0];\n  for (let p = 1; p < str.length; p++) {\n    if (str[p] === quoteType && (p === 1 || str[p - 1] !== \"\\\\\") && p !== str.length - 1) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction rmEscapes(str) {\n  if (!str.length)\n    return \"\";\n  let clean = \"\";\n  let lastChar = \"\";\n  for (let p = 0; p < str.length; p++) {\n    const char = str.charAt(p);\n    if (char !== \"\\\\\" || lastChar === \"\\\\\") {\n      clean += char;\n    }\n    lastChar = char;\n  }\n  return clean;\n}\nfunction assignDeep(a, b) {\n  for (const key in a) {\n    if (has(b, key) && a[key] !== b[key] && !(isPojo(a[key]) && isPojo(b[key]))) {\n      a[key] = b[key];\n    } else if (isPojo(a[key]) && isPojo(b[key])) {\n      assignDeep(a[key], b[key]);\n    }\n  }\n  for (const key in b) {\n    if (!has(a, key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n}\nfunction nodeProps(...sets) {\n  return sets.reduce((valid, props) => {\n    const { value, name, modelValue, config, plugins, ...validProps } = props;\n    return Object.assign(valid, validProps);\n  }, {});\n}\nfunction parseArgs(str) {\n  const args = [];\n  let arg = \"\";\n  let depth = 0;\n  let quote = \"\";\n  let lastChar = \"\";\n  for (let p = 0; p < str.length; p++) {\n    const char = str.charAt(p);\n    if (char === quote && lastChar !== \"\\\\\") {\n      quote = \"\";\n    } else if ((char === \"'\" || char === '\"') && !quote && lastChar !== \"\\\\\") {\n      quote = char;\n    } else if (char === \"(\" && !quote) {\n      depth++;\n    } else if (char === \")\" && !quote) {\n      depth--;\n    }\n    if (char === \",\" && !quote && depth === 0) {\n      args.push(arg);\n      arg = \"\";\n    } else if (char !== \" \" || quote) {\n      arg += char;\n    }\n    lastChar = char;\n  }\n  if (arg) {\n    args.push(arg);\n  }\n  return args;\n}\nfunction except(obj, toRemove) {\n  const clean = {};\n  const exps = toRemove.filter((n) => n instanceof RegExp);\n  const keysToRemove = new Set(toRemove);\n  for (const key in obj) {\n    if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {\n      clean[key] = obj[key];\n    }\n  }\n  return clean;\n}\nfunction only(obj, include) {\n  const clean = {};\n  const exps = include.filter((n) => n instanceof RegExp);\n  include.forEach((key) => {\n    if (!(key instanceof RegExp)) {\n      clean[key] = obj[key];\n    }\n  });\n  Object.keys(obj).forEach((key) => {\n    if (exps.some((exp) => exp.test(key))) {\n      clean[key] = obj[key];\n    }\n  });\n  return clean;\n}\nfunction camel(str) {\n  return str.replace(\n    /-([a-z0-9])/gi,\n    (_s, g) => g.toUpperCase()\n  );\n}\nfunction kebab(str) {\n  return str.replace(\n    /([a-z0-9])([A-Z])/g,\n    (_s, trail, cap) => trail + \"-\" + cap.toLowerCase()\n  ).replace(\" \", \"-\").toLowerCase();\n}\nfunction shallowClone(obj, explicit = explicitKeys) {\n  if (obj !== null && typeof obj === \"object\") {\n    let returnObject;\n    if (Array.isArray(obj))\n      returnObject = [...obj];\n    else if (isPojo(obj))\n      returnObject = { ...obj };\n    if (returnObject) {\n      applyExplicit(obj, returnObject, explicit);\n      return returnObject;\n    }\n  }\n  return obj;\n}\nfunction clone(obj, explicit = explicitKeys) {\n  if (obj === null || obj instanceof RegExp || obj instanceof Date || obj instanceof Map || obj instanceof Set || typeof File === \"function\" && obj instanceof File)\n    return obj;\n  let returnObject;\n  if (Array.isArray(obj)) {\n    returnObject = obj.map((value) => {\n      if (typeof value === \"object\")\n        return clone(value, explicit);\n      return value;\n    });\n  } else {\n    returnObject = Object.keys(obj).reduce((newObj, key) => {\n      newObj[key] = typeof obj[key] === \"object\" ? clone(obj[key], explicit) : obj[key];\n      return newObj;\n    }, {});\n  }\n  for (const key of explicit) {\n    if (key in obj) {\n      Object.defineProperty(returnObject, key, {\n        enumerable: false,\n        value: obj[key]\n      });\n    }\n  }\n  return returnObject;\n}\nfunction cloneAny(obj) {\n  return typeof obj === \"object\" ? clone(obj) : obj;\n}\nfunction getAt(obj, addr) {\n  if (!obj || typeof obj !== \"object\")\n    return null;\n  const segments = addr.split(\".\");\n  let o = obj;\n  for (const i in segments) {\n    const segment = segments[i];\n    if (has(o, segment)) {\n      o = o[segment];\n    }\n    if (+i === segments.length - 1)\n      return o;\n    if (!o || typeof o !== \"object\")\n      return null;\n  }\n  return null;\n}\nfunction undefine(value) {\n  return value !== void 0 && value !== \"false\" && value !== false ? true : void 0;\n}\nfunction init(obj) {\n  return !Object.isFrozen(obj) ? Object.defineProperty(obj, \"__init\", {\n    enumerable: false,\n    value: true\n  }) : obj;\n}\nfunction slugify(str) {\n  return str.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").toLowerCase().replace(/[^a-z0-9]/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\nfunction spread(obj, explicit = explicitKeys) {\n  if (obj && typeof obj === \"object\") {\n    if (obj instanceof RegExp)\n      return obj;\n    if (obj instanceof Date)\n      return obj;\n    let spread2;\n    if (Array.isArray(obj)) {\n      spread2 = [...obj];\n    } else {\n      spread2 = { ...obj };\n    }\n    return applyExplicit(\n      obj,\n      spread2,\n      explicit\n    );\n  }\n  return obj;\n}\nfunction applyExplicit(original, obj, explicit) {\n  for (const key of explicit) {\n    if (key in original) {\n      Object.defineProperty(obj, key, {\n        enumerable: false,\n        value: original[key]\n      });\n    }\n  }\n  return obj;\n}\nfunction whenAvailable(childId, callback, root) {\n  if (!isBrowser)\n    return;\n  if (!root)\n    root = document;\n  const el = root.getElementById(childId);\n  if (el)\n    return callback(el);\n  const observer = new MutationObserver(() => {\n    const el2 = root?.getElementById(childId);\n    if (el2) {\n      observer?.disconnect();\n      callback(el2);\n    }\n  });\n  observer.observe(root, { childList: true, subtree: true });\n}\nfunction oncePerTick(fn) {\n  let called = false;\n  return (...args) => {\n    if (called)\n      return;\n    called = true;\n    queueMicrotask(() => called = false);\n    return fn(...args);\n  };\n}\nfunction boolGetter(value) {\n  if (value === \"false\" || value === false)\n    return void 0;\n  return true;\n}\n\nexport { assignDeep, boolGetter, camel, clone, cloneAny, dedupe, empty, eq, eqRegExp, escapeExp, except, extend, getAt, has, init, isObject, isPojo, isQuotedString, isRecord, kebab, nodeProps, nodeType, oncePerTick, only, parseArgs, regexForFormat, rmEscapes, setify, shallowClone, slugify, spread, token, undefine, whenAvailable };\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map",
      "start": 1709718916275,
      "end": 1709718916351,
      "sourcemaps": null
    },
    {
      "name": "unplugin-formkit",
      "start": 1709718916351,
      "end": 1709718916351,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1709718916351,
      "end": 1709718916351,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1709718916351,
      "end": 1709718916352,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "post"
    },
    {
      "name": "element-plus:transform",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1709718916352,
      "end": 1709718916352,
      "order": "normal"
    }
  ]
}
